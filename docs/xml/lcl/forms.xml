<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>
  <package name="lcl">
    <!--
    ====================================================================
      Forms
    ====================================================================
    -->
    <module name="Forms">
      <short>
        Implements Forms, which are the basis for the Lazarus Graphical User Interface
      </short>
      <descr>
        <p>
          <file>forms.pp</file> contains classes, types, and routines used to implement forms, which are used as the basis a graphical user interface in the Lazarus Component Library (<b>LCL</b>).
        </p>
        <p>
          The following components are added to the Lazarus IDE component palette:
        </p>
        <p>
          <b>Standard</b> Tab
        </p>
        <ul>
          <li>TFrame</li>
        </ul>
        <p>
          <b>Additional </b>Tab
        </p>
        <ul>
          <li>TScrollBox</li>
          <li>TApplicationProperties</li>
        </ul>
        <p>
          The unit also includes the TApplication and TScreen classes used in the Application and Screen singletons.
        </p>
      </descr>

      <!-- unresolved type references -->
      <element name="Classes"/>
      <element name="SysUtils"/>
      <element name="Types"/>
      <element name="TypInfo"/>
      <element name="Math"/>
      <element name="CustApp"/>
      <element name="LCLStrConsts"/>
      <element name="LCLType"/>
      <element name="LCLProc"/>
      <element name="LCLIntf"/>
      <element name="LCLVersion"/>
      <element name="LCLClasses"/>
      <element name="InterfaceBase"/>
      <element name="LResources"/>
      <element name="Graphics"/>
      <element name="Menus"/>
      <element name="LMessages"/>
      <element name="CustomTimer"/>
      <element name="ActnList"/>
      <element name="ClipBrd"/>
      <element name="HelpIntfs"/>
      <element name="Controls"/>
      <element name="ImgList"/>
      <element name="Themes"/>
      <element name="LazFileUtils"/>
      <element name="LazUTF8"/>
      <element name="Maps"/>
      <element name="IntegerList"/>
      <element name="LazMethodList"/>
      <element name="LazLoggerBase"/>
      <element name="LazUtilities"/>
      <element name="GraphType"/>
      <element name="UITypes"/>
      <element name="gettext"/>

      <!-- procedure type Visibility: default -->
      <element name="TProcedure">
        <short>The type of a procedure that takes no arguments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TProcedureOfObject">
        <short>The type of a method that takes no arguments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPosition">
        <short>Represents the Position and Size of a Form on Screen</short>
        <descr>
          <p>
            <var>TPosition</var> is an enumerated type with values that describe the policy used to position and size a form instance in an application. TPosition is the type used to implement the <var>Position</var> property in <var>TCustomForm</var>. TPosition is used in the implementation of the <var>MoveToDefaultPosition</var> method in TCustomForm.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Position"/>
          <link id="TCustomForm.MoveToDefaultPosition"/>
        </seealso>
      </element>
      <element name="TPosition.poDesigned">
        <short>The Form appears exactly as it is positioned and sized in the Form Designer.
        </short>
      </element>
      <element name="TPosition.poDefault">
        <short>
          The window manager decides how the form is to appear, in a default position and size.
        </short>
      </element>
      <element name="TPosition.poDefaultPosOnly">
        <short>
          Keeps the designed form size, but position determined by windowmanager.
        </short>
      </element>
      <element name="TPosition.poDefaultSizeOnly">
        <short>
          Keeps the designed form position, but size determined by windowmanager.
        </short>
      </element>
      <element name="TPosition.poScreenCenter">
        <short>Centers the form on screen.
        </short>
      </element>
      <element name="TPosition.poDesktopCenter">
        <short>
          Centers the form on the desktop (not recommended, use poScreenCenter).
        </short>
      </element>
      <element name="TPosition.poMainFormCenter">
        <short>Centers the form on the Main Form</short>
      </element>
      <element name="TPosition.poOwnerFormCenter">
        <short>Centers the form on its Owner form</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWindowState">
        <short>Represents the actual State of the window on the screen</short>
        <descr>
          <p>
            The actual meaning of each value depends on the platform:
          </p>
          <dl>
            <dt>Windows and Mac OS X</dt>
            <dd>These operating systems support all values.</dd>
            <dt>X11</dt>
            <dd>
              The window state is a hint sent to the Window Manager, so more primitive Window Managers might ignore these hints.
            </dd>
            <dt>Windows CE</dt>
            <dd>
              In Windows CE platforms where Application.ApplicationType = atKeyPadDevice or atPDA (like in Windows Phone, PocketPC and Windows Mobile), wsMinimized and wsNormal are understood as wsMaximized, which is the normal state for windows in this platform. An exception are windows with BorderStyle=bsDialog or bsNone, which are allowed to have a custom position and size. For more information please read the <url href="http://wiki.lazarus.freepascal.org/Windows_CE_Development_Notes#Positioning_and_size_of_Dialogs_and_Forms">Lazarus Wiki article</url>.
            </dd>
            <dt>Android</dt>
            <dd>In this platform windows are always fullscreen.</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TWindowState.wsNormal">
        <short>Neither maximized nor minimized</short>
      </element>
      <element name="TWindowState.wsMinimized">
        <short>The window is minimized and is not shown in the screen, but only in the taskbar</short>
      </element>
      <element name="TWindowState.wsMaximized">
        <short>
          The window appears maximized. The exact behavior is up to the window manager, but usually the window appear occupying all of the work area of a monitor.
        </short>
      </element>
      <element name="TWindowState.wsFullScreen">
        <short>
          The window appears in full screen mode, when allowed by the platform. It will, for example, attempt to appear on the top of taskbars and other static platform user interface elements.
        </short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TCloseAction">
        <short>What should happen when a form is closed</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnClose">TCustomForm.OnClose</link>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caNone">
        <short>Do nothing</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caHide">
        <short>The form is hidden</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caFree">
        <short>The form is destroyed</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caMinimize">
        <short>The form is minimized</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomHintAction">
        <short>
          Represents a standard action used to get a Hint value
        </short>
        <descr>
          <p>
            <var>TCustomHintAction</var> is a <var>TCustomAction</var> descendant. TCustomHintAction publishes the Hint property available in the ancestor. TCustomHintAction is the base class for THintAction defined in the <file>StdActns</file> unit.
          </p>
          <p>
            TCustomHintAction is used in <var>TApplication</var> when setting the value for its Hint property and its <var>OnHint</var> event handler has not been assigned. TCustomHintAction is also used in the <var>ExecuteAction</var> method in <var>TStatusBar</var> when its <var>AutoHint</var> property is enabled.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.Hint"/>
          <link id="TApplication.OnHint"/>
          <link id="#lcl.comctrls.TStatusBar.ExecuteAction">TStatusBar.ExecuteAction</link>
          <link id="#lcl.stdactns.THintAction">THintAction</link>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TCustomHintAction.Hint" link="#lcl.actnlist.TCustomAction.Hint">
        <short>The text used for the Hint</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScrollBarKind">
        <short>The orientation of a ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TScrollBarKind.sbHorizontal">
        <short>Horizontal scrollbar</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TScrollBarKind.sbVertical">
        <short>Vertical scrollbar</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TScrollBarInc">
        <short>The range of scrollbar increments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScrollBarStyle">
        <short>Scrollbar style flags</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollBarStyle.ssRegular">
        <short>Default</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <element name="TScrollBarStyle.ssFlat">
        <short>Scrollbar appears flat</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <element name="TScrollBarStyle.ssHotTrack">
        <short>Scrollbar sends HotTrack messages</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <!-- object Visibility: default -->
      <element name="EScrollBar">
        <short>Exception class raised in <link id="TControlScrollBar"/></short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlScrollBar">
        <short>Type for a scrollbar in TScrollingWinControl</short>
        <descr>
          <p>
            Scrollable controls supply their own <b>integrated</b> scrollbars, one for horizontal and one for vertical scrolling. This class allows access to (one of) these integrated scrollbars.
          </p>
          <p>
            A scrollable control has both a physical (visible) client size, and a logical (virtual) client size.
          </p>
          <p>
            The <var>Range</var> property reflects the total virtual client size, in pixels.
          </p>
          <p>
            The <var>Page</var> property corresponds to physical (visible) client size, in pixels, excluding the scrollbars. It also determines the size of the slider, relative to the total Range.
          </p>
          <p>
            The <var>Position</var> property reflects the virtual origin of the visible client area, equivalent to the top coordinate of the slider. The Position can be changed by the user or by code.
          </p>
          <p>
            Scrollbars usually appear only when Range is higher than Page, i.e. when not the entire content can be shown at the same time. See the ScrollBar property of the scrolling control for details.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl"/>
          <link id="TScrollBox"/>
          <link id="TCustomForm"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FAutoRange">
        <short>
          The virtual scroll range (FRange - ClientSize), at least zero (never negative)
        </short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FIncrement" link="#lcl.forms.TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.FKind" link="#lcl.forms.TControlScrollBar.Kind"/>
      <element name="TControlScrollBar.FPage" link="#lcl.forms.TControlScrollBar.Page"/>
      <element name="TControlScrollBar.FRange" link="#lcl.forms.TControlScrollBar.Range"/>
      <element name="TControlScrollBar.FSmooth" link="#lcl.forms.TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.FTracking" link="#lcl.forms.TControlScrollBar.Tracking"/>
      <element name="TControlScrollBar.FVisible" link="#lcl.forms.TControlScrollBar.Visible"/>
      <element name="TControlScrollBar.FOldScrollInfo"/>
      <element name="TControlScrollBar.FOldScrollInfoValid"/>
      <element name="TControlScrollBar.FControl">
        <short>The associated <link id="TScrollingWinControl"/></short>
      </element>
      <element name="TControlScrollBar.FPosition" link="#lcl.forms.TControlScrollBar.Position"/>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.ControlHandle">
        <short>The Handle for the associated <link id="TScrollingWinControl"/></short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ControlHandle.Result">
        <short>The handle for the associated control</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetAutoScroll">
        <short>The AutoScroll state for the associated TScrollingWinControl control</short>
        <descr>
          <remark>
            GetAutoScroll is not used as the read access specifier for the AutoScroll property. It is used in methods to ensure that the class reflects the current state for its associated control.
          </remark>
        </descr>
        <seealso>
          <link id="TControlScrollBar.AutoScroll"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.GetAutoScroll.Result">
        <short>
          True when the Control for the class instance has set its AutoScroll property
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetIncrement" link="#lcl.forms.TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.GetIncrement.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.GetPage" link="#lcl.forms.TControlScrollBar.Page"/>
      <element name="TControlScrollBar.GetPage.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.GetPosition" link="#lcl.forms.TControlScrollBar.Position"/>
      <element name="TControlScrollBar.GetPosition.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.GetRange" link="#lcl.forms.TControlScrollBar.Range"/>
      <element name="TControlScrollBar.GetRange.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.GetSize" link="#lcl.forms.TControlScrollBar.Size"/>
      <element name="TControlScrollBar.GetSize.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.GetSmooth" link="#lcl.forms.TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.GetSmooth.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.HandleAllocated">
        <short>True when the associated <link id="TScrollingWinControl"/> has a handle allocated</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.HandleAllocated.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.IsRangeStored" link="#lcl.forms.TControlScrollBar.Range"/>
      <element name="TControlScrollBar.IsRangeStored.Result">
        <short/>
      </element>
      <element name="TControlScrollBar.AutoCalcRange">
        <short>Determines the scrollbar Range, using the physical and virtual size for the associated control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ControlUpdateScrollBars">
        <short>Notifies the associated Control of changes</short>
        <descr/>
        <seealso>
          <link id="TScrollingWinControl.UpdateScrollBars"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.InternalSetRange">
        <short>Checks and updates the new range for scrollbars in the Control</short>
        <descr/>
        <seealso>
          <link id="TControlScrollBar.ControlUpdateScrollBars"/>
          <link id="TScrollingWinControl.UpdateScrollBars"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.InternalSetRange.AValue">
        <short/>
      </element>
      <element name="TControlScrollBar.ScrollHandler">
        <short>Handler for the ScrollBar movement messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ScrollHandler.Message">
        <short>Message examined in the method</short>
      </element>
      <element name="TControlScrollBar.SetIncrement" link="#lcl.forms.TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.SetIncrement.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetPage" link="#lcl.forms.TControlScrollBar.Page"/>
      <element name="TControlScrollBar.SetPage.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetPosition" link="#lcl.forms.TControlScrollBar.Position"/>
      <element name="TControlScrollBar.SetPosition.Value">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetRange" link="#lcl.forms.TControlScrollBar.Range"/>
      <element name="TControlScrollBar.SetRange.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetSize" link="#lcl.forms.TControlScrollBar.Size"/>
      <element name="TControlScrollBar.SetSize.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetSmooth" link="#lcl.forms.TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.SetSmooth.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetTracking" link="#lcl.forms.TControlScrollBar.Tracking"/>
      <element name="TControlScrollBar.SetTracking.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.SetVisible" link="#lcl.forms.TControlScrollBar.Visible"/>
      <element name="TControlScrollBar.SetVisible.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TControlScrollBar.UpdateScrollBar">
        <short>
          Updates the state and position for the scroll bar in the associated Control
        </short>
        <descr>
          <p>
            <var>UpdateScrollBar</var> is a procedure used to update the state and position for the scroll bar in the associated <var>Control</var>.
          </p>
          <p>
            When <var>Control</var> is a <var>TScrollingWinControl</var> instance, <var>TScrollInfo</var> is captured using the <var>Range</var>, <var>Position</var>, and <var>Page</var> properties. The scroll bar information is applied to the associated control by calling <var>SetScrollInfo</var>.
          </p>
          <remark>
            Please note: <var>TScrollInfo</var> values are not applied when a handle has not been allocated for the control, or when <var>Control</var> is not a <var>TScrollingWinControl</var> class instance.
          </remark>
          <p>
            <var>UpdateScrollBar</var> calls <var>SetPosition</var> to apply the current value in <var>Position</var> to a visible scroll bar in the class instance. When <var>Control</var> is a <var>TScrollingWinControl</var> instance, the <var>Smooth</var> property is used to determine if <var>Increment</var> needs to be adjusted to a value that is 10% of the <var>Page</var> size for the control.
          </p>
          <p>
            <var>UpdateScrollBar</var> is used in the implementation of the <var>ControlUpdateScrollBars</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Increment"/>
          <link id="TControlScrollBar.Page"/>
          <link id="TControlScrollBar.Smooth"/>
          <link id="TControlScrollBar.Range"/>
          <link id="TControlScrollBar.ControlUpdateScrollBars"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.InvalidateScrollInfo">
        <short>Renders scroll information invalid for the control</short>
        <descr>
          <p>
            <var>InvalidateScrollInfo</var> is used to mark the current <var>TScrollInfo</var> in the control as invalid. This occurs when a new value is assigned to the <var>Position</var> property, and when <var>ScrollHandler</var> applies position information found in <var>TLMScroll</var> messages. Calling InvalidateScrollInfo results in TScrollInfo being updated and applied for scrolling window controls in the <var>UpdateScrollBar</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Position"/>
          <link id="TControlScrollBar.UpdateScrollBar"/>
          <link id="TControlScrollBar.ScrollHandler"/>
          <link id="#lcl.lmessages.TLMScroll">TLMScroll</link>
        </seealso>
      </element>
      <!-- Visibility: public -->
      <element name="TControlScrollBar.GetHorzScrollBar">
        <short>Get the horizontal scrollbar for the Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetHorzScrollBar.Result">
        <short>TControlScrollBar instance representing the scrollbar</short>
      </element>
      <element name="TControlScrollBar.GetVertScrollBar">
        <short>Get the vertical scrollbar for the Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetVertScrollBar.Result">
        <short>
          Scrollbar for the control, or Nil when not a TScrollingWinControl descendant
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.ScrollBarShouldBeVisible">
        <short>Determines whether a scrollbar is required</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ScrollBarShouldBeVisible.Result">
        <short>True when Visible, and Range is larger than the Page size</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlScrollBar.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            Create is the constructor for the class instance, and calls the inherited constructor on entry.
          </p>
          <p>
            Create sets the Control and Kind properties to the values specified in the AControl and AKind arguments. Create sets the default values for properties, including:
          </p>
          <dl>
            <dt>Page</dt>
            <dd>Set to 80.</dd>
            <dt>Increment</dt>
            <dd>Set to 8.</dd>
            <dt>Position and Range</dt>
            <dd>Set to 0 (zero).</dd>
            <dt>Smooth and Tracking</dt>
            <dd>Set to False.</dd>
            <dt>Visible</dt>
            <dd>Set to True.</dd>
          </dl>
        </descr>
        <seealso>
          <link id="#rtl.system.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TControlScrollBar.Create.AControl">
        <short>The windowed control in which the scroll bar is found</short>
      </element>
      <element name="TControlScrollBar.Create.AKind">
        <short>The scrollbar orientation</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlScrollBar.Assign">
        <short>
          If Source is a <var>TControlScrollBar</var>, copies properties to itself, else performs inherited <var>Assign</var>
        </short>
        <descr>
          <p>
            Assigns the contents of the source object to the current object; in particular finds the Increment, Position, Range and whether smooth scrolling is to  be feature and whether the scroll bar is visible.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Increment"/>
          <link id="TControlScrollBar.Position"/>
          <link id="TControlScrollBar.Range"/>
          <link id="#rtl.classes.TPersistent.Assign">TPersistent.Assign</link>
        </seealso>
      </element>
      <element name="TControlScrollBar.Assign.Source">
        <short>
          TControlScrollBar instance with the values copied in the method
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.IsScrollBarVisible">
        <short>Determines the current widget state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.IsScrollBarVisible.Result">
        <short>True if scrollbar is visible</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ScrollPos">
        <short>The scroll Position, zero if not Visible</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ScrollPos.Result">
        <short>The scroll Position, zero if not Visible</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.GetOtherScrollBar">
        <short>Get the ScrollBar with the opposite orientation (horz/vert) for the current instance</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetOtherScrollBar.Result">
        <short>TControlScrollBar instance for the opposite orientation</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSize">
        <short>
          Gets the size for the scroll bar based on the client area in the associated control
        </short>
        <descr>
          <p>
            <var>ClientSize</var> is an <var>Integer</var> function used to get the size from the client area in the associated control. ClientSize uses the value in Kind to determine whether the height or width for the associated control is used as the return value. For example:
          </p>
          <dl>
            <dt>sbVertical</dt>
            <dd>Returns the client width from the associated control.</dd>
            <dt>sbHorizontal</dt>
            <dd>Returns the client height from the associated control.</dd>
          </dl>
          <p>
            ClientSize is used in methods like <var>ClientSizeWithBar</var> and    <var>ClientSizeWithoutBar</var> to get the size for the scroll bar adjusted for scroll bar spacing returned from <var>GetSystemMetrics</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Kind"/>
          <link id="TControlScrollBar.FControl"/>
          <link id="TControlScrollBar.ClientSizeWithBar"/>
          <link id="TControlScrollBar.ClientSizeWithoutBar"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.ClientSize.Result">
        <short>Size from the client area in the associated control</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSizeWithBar">
        <short>
          Calculates the size of the associated control when the scroll bar is Visible
        </short>
        <descr>
          <p>
            <var>ClientSizeWithBar</var> is an <var>Integer</var> function used to calculate the client area for the associated control when the scroll bar is <var>Visible</var>. The return value contains the calculated value from <var>ClientSize</var>. If the scroll bar is not Visible, additional spacing (for the SM_SWSCROLLBARSPACING system metric) between the scroll bar and its associated control is removed from the return value.
          </p>
          <p>
            ClientSizeWithBar is used in the implementation of the <var>ComputeScrollbars</var> method in <var>TScrollingWinControl</var> when the <var>Range</var> for the scroll bar would exceed the space available on the control, and in the <var>GetPreferredSizeClientFrame</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.ClientSize"/>
          <link id="TControlScrollBar.Visible"/>
          <link id="TControlScrollBar.Range"/>
          <link id="TScrollingWinControl.ComputeScrollbars"/>
          <link id="TScrollingWinControl.GetPreferredSizeClientFrame"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.ClientSizeWithBar.Result">
        <short>
          Size for the client area after adjusting for a visible scroll bar
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSizeWithoutBar">
        <short>
          Calculates the size of the associated control when the scroll bar is not Visible
        </short>
        <descr>
          <p>
            <var>ClientSizeWithoutBar</var> is an <var>Integer</var> function used to calculate the client area for the associated control when the scroll bar is <var>Visible</var>. The return value contains the calculated value from <var>ClientSize</var>. If the scroll bar is Visible, additional spacing (for the SM_SWSCROLLBARSPACING system metric) between the scroll bar and its associated control is added to the return value.
          </p>
          <p>
            ClientSizeWithoutBar is used in the implementation of the <var>ComputeScrollbars</var> and <var>GetPreferredSizeClientFrame</var> methods in <var>TScrollingWinControl</var>.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.ClientSize"/>
          <link id="TControlScrollBar.Visible"/>
          <link id="TControlScrollBar.Range"/>
          <link id="TScrollingWinControl.ComputeScrollbars"/>
          <link id="TScrollingWinControl.GetPreferredSizeClientFrame"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.ClientSizeWithoutBar.Result">
        <short>
          Size for the client area after adjusting for a hidden scroll bar
        </short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Increment">
        <short>
          The small Position increment, applicable to the scrollbar arrows
        </short>
        <descr>
          <p>
            <var>Increment</var> is a <var>TScrollBarInc</var> property which indicates the amount the client area in the associated control is scrolled when the <b>Up</b> or <b>Down</b> navigation arrows on the scroll bar are clicked. The default value is <b>8</b>.
          </p>
          <p>
            The value in Increment may be automatically recalculated in the <var>UpdateScrollBar</var> method if the <var>Smooth</var> property is enabled, and the associated control is a <var>TScrollingWinControl</var> descendant. This is done to ensure that Increment contains 10% of the value for the <var>Page</var> property.
          </p>
          <p>
            Increment is used in the <var>ScrollHandler</var> method when updating the <var>Position</var> property for scroll bar messages received in the control.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.UpdateScrollBar"/>
          <link id="TControlScrollBar.ControlUpdateScrollBars"/>
          <link id="TControlScrollBar.Smooth"/>
          <link id="TControlScrollBar.Page"/>
          <link id="TControlScrollBar.ScrollHandler"/>
          <link id="TScrollingWinControl"/>
          <link id="TScrollBarInc"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlScrollBar.Kind">
        <short>The orientation for the scroll bar: horizontal or vertical</short>
        <descr>
          <p>
            <var>Kind</var> is a read-only <var>TScrollBarKind</var> property which indicates the orientation for the scroll bar. The value for Kind is passed as an argument to the <var>Create</var> constructor, and stored in the property. The value in Kind is used in methods which update properties or state for the control, such as:
          </p>
          <ul>
            <li>Position</li>
            <li>Range</li>
            <li>Page</li>
            <li>Tracking</li>
            <li>Size</li>
            <li>ClientSize</li>
            <li>ControlSize</li>
            <li>IsScrollBarVisible</li>
            <li>GetOtherScrollBar</li>
            <li>UpdateScrollBar</li>
          </ul>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Create"/>
        </seealso>
      </element>

      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Page">
        <short>
          The slider size, position increment applicable to the scrollbar area beneath the slider
        </short>
        <descr>
          <p>
            The amount by which the scroll indicator moves if the cursor selects the scroll bar above, below or on either side of the scroll indicator. The default value is 80.
          </p>
        </descr>
        <seealso/>
      </element>

      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Position">
        <short>Position of the slider, 0..Range-Page</short>
        <descr>
          <p>
            The Position reflects the top coordinate of the slider, which is Range-Page when the slider is at the bottom of the bar.
          </p>
        </descr>
        <seealso/>
      </element>

      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Smooth">
        <short>
          Enables smooth scrolling, with automatic adjustment of Increment and Page
        </short>
        <descr>
          <p>
            <var>Smooth</var> is a <var>Boolean</var> property that indicates if the associated control is scrolled using an Increment value computed to be 10% of the Page size for the scroll bar. Set Smooth to <b>True</b> when the scroll bar should use a scrolling increment based on the size of the client area in the associated control. When Smooth is set to <b>False</b>, the <var>Increment</var> property determines the size for the scroll operation when the Up or Down arrows are clicked.
          </p>
          <p>
            Smooth is used in the <var>UpdateScrollBar</var> method, and when set to <b>True</b> causes the value in Increment to be recalculated using the proportional size value. Smooth is relevant when the associated control is descended from <var>TScrollingWinControl</var>.
          </p>
          <p>
            The default value for the property is <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Increment"/>
          <link id="TControlScrollBar.Page"/>
          <link id="TControlScrollBar.UpdateScrollBar"/>
          <link id="TScrollingWinControl"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.SmoothIsStored" link="#lcl.forms.TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.SmoothIsStored.Result">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Range">
        <short>The virtual size of the Parent Control</short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlScrollBar.Size">
        <short>The adjustable size of the scroll bar</short>
        <descr>
          <p>
            The length of the bar is the Width (or Height) of the Parent Control, the Size is the other (free) coordinate.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Tracking">
        <short>Gives feedback while the slider is dragged</short>
        <descr>
          <p>
            When it takes an significant amount of time, to repaint the parent control at a new position, Tracking should be False to prevent flicker; then the control is updated only when the slider is released.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Visible">
        <short>Hides the scrollbar when False (default True)</short>
        <descr>
          <p>
            The scrollbar widget is visible only if (Visible=True) <b>and</b> (Range&gt;Page).
          </p>
          <p>
            Set Visible to False to disallow the user to scroll the content, while the content still can be scrolled by code.
          </p>
          <p>
            Use IsScrollBarVisible to get the current visible state of the widget.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.IsScrollBarVisible"/>
        </seealso>
      </element>
<!-- object Visibility: default -->
      <element name="TScrollingWinControl">
        <short>Class of a windowed control with incorporated scroll bars</short>
        <descr>
          <p>
            This class introduces a logical (virtual) client area, part of which is visible in the physical (visible) client area. <link id="TControlScrollBar">ScrollBars</link> allow the user to scroll through the logical client area.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar"/>
          <link id="TForm"/>
          <link id="TScrollBox"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScrollingWinControl.FHorzScrollBar" link="#lcl.forms.TScrollingWinControl.HorzScrollBar"/>
      <element name="TScrollingWinControl.FVertScrollBar" link="#lcl.forms.TScrollingWinControl.VertScrollBar"/>
      <element name="TScrollingWinControl.FAutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <!-- variable Visibility: private -->
      <element name="TScrollingWinControl.FIsUpdating">
        <short>Prevents recursive updates, True while an update is already in progress</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetHorzScrollBar" link="#lcl.forms.TScrollingWinControl.HorzScrollBar"/>
      <element name="TScrollingWinControl.SetHorzScrollBar.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetVertScrollBar" link="#lcl.forms.TScrollingWinControl.VertScrollBar"/>
      <element name="TScrollingWinControl.SetVertScrollBar.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.AlignControls" link="#lcl.controls.TWinControl.AlignControls">
        <short>Also calculates sizes for the scrollbars if required</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.AlignControls">TWinControl.AlignControls</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.AlignControls.AControl">
        <short/>
      </element>
      <element name="TScrollingWinControl.AlignControls.ARect">
        <short/>
      </element>
      <element name="TScrollingWinControl.AutoScrollEnabled">
        <short>Indicates if automatic scrolling is enabled for the control</short>
        <descr>
          <p>
            <var>AutoScrollEnabled</var> is a <var>Boolean</var> function which indicates if automatic scrolling is enabled for the control. The return value is <b>True</b> when the control is <b>NOT</b> automatically resized, or used as a docksite by an active docking manager.
          </p>
          <p>
            Use the <var>AutoSize</var> property to enabled or disable automatic control resizing. Set the <var>UseDockManager</var> property to <b>False</b> to disable use of the <var>DockSite</var> for the control.
          </p>
        </descr>
        <seealso>
          <link id="TScrollBox.AutoSize"/>
          <link id="TScrollBox.DockSite"/>
          <link id="TWinControl.UseDockManager"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.AutoScrollEnabled.Result">
        <short>True when not automatically resized or used as a dock site</short>
      </element>
      <element name="TScrollingWinControl.CalculateAutoRanges">
        <short>Sets or resets the ranges used for scrollbars in the control</short>
        <descr>Used in the implementation of the ComputeScrollbars method.</descr>
        <seealso>
          <link id="TScrollingWinControl.ComputeScrollbars"/>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.CreateWnd" link="#lcl.controls.TWinControl.CreateWnd"/>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetClientScrollOffset">
        <short>The virtual origin of the physical client area</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.GetClientScrollOffset">TControl.GetClientScrollOffset</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetClientScrollOffset.Result">
        <short>The ScrollBar Positions, or (0,0) if no scrollbars in use</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetLogicalClientRect" link="#lcl.controls.TControl.GetLogicalClientRect">
        <short>Returns the full virtual ClientRect.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.GetLogicalClientRect">TControl.GetLogicalClientRect</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetLogicalClientRect.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.DoOnResize" link="#lcl.controls.TControl.DoOnResize">
        <short>Also updates scrollbars if needed</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.DoOnResize">TControl.DoOnResize</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame">
        <short>
          Calculates the size of the client area for the control excluding visible scroll bars
        </short>
        <descr/>
        <seealso>
          <link id="TScrollingWinControl.AutoScroll"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="#lcl.controls.TControl.Height">TControl.Height</link>
          <link id="#lcl.controls.TControl.Width">TControl.Width</link>
          <link id="#lcl.controls.TControl.ClientHeight">TControl.ClientHeight</link>
          <link id="#lcl.controls.TControl.ClientWidth">TControl.ClientWidth</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame.aWidth">
        <short>Width of the client area</short>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame.aHeight">
        <short>Height of the client area</short>
      </element>
      <element name="TScrollingWinControl.WMSize">
        <short>Performs actions needed to handle WMSize messages</short>
        <descr>
          <p>
            <var>WMSize</var> is a procedure used to perform actions needed to handle WMSize messages for the control. WMSize calls the inherited WMSize method to set the bounds for the control, optionally using the bounds from the parent control.
          </p>
          <p>
            WMSize provides support for setting the window state based on size messages that originate in the LCL interface, and calls <var>Resizing</var> to realize the new window state.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="TControl.WMSize"/>
          <link id="TScrollingWinControl.Resizing"/>
          <link id="TWindowState"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.WMSize.Message">
        <short>Message examined in the method</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WMHScroll">
        <short>Delegates scroll messages to the horizontal ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.WMHScroll.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WMVScroll">
        <short>Delegates scroll messages to the vertical ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.WMVScroll.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.ComputeScrollbars">
        <short>Updates Page, AutoRange, IsScrollBarVisible, returns True on changes</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TScrollingWinControl.ComputeScrollbars.Result">
        <short>True when something has changed</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetAutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <element name="TScrollingWinControl.SetAutoScroll.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.Loaded">
        <short>Also initializes the scroll bars</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.Loaded">TWinControl.Loaded</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.Resizing">
        <short>
          Performs actions needed when the control processes the WMSize message
        </short>
        <descr>
          <p>
            Resizing is an empty implementation in TScrollingWinControl. It must be implemented in descendent form or control classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.Resizing.State">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.AutoScroll">
        <short>Allows ScrollBars to be displayed only when needed (when True)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.SetAutoSize" link="#lcl.controls.TControl.AutoSize"/>
      <element name="TScrollingWinControl.SetAutoSize.Value">
        <short>New value for the property</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TScrollingWinControl.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TScrollingWinControl.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TScrollingWinControl.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. Destroy frees resources allocated for the <var>HorzScrollBar</var> and <var>VertScrollBar</var> properties. Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.ScreenToClient" link="#lcl.controls.TControl.ScreenToClient"/>
      <element name="TScrollingWinControl.ScreenToClient.Result">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScreenToClient.APoint">
        <short/>
      </element>
      <element name="TScrollingWinControl.ClientToScreen" link="#lcl.controls.TControl.ClientToScreen"/>
      <element name="TScrollingWinControl.ClientToScreen.Result">
        <short/>
      </element>
      <element name="TScrollingWinControl.ClientToScreen.APoint">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScrollingWinControl.UpdateScrollbars">
        <short>Initializes or updates the ScrollBars for the control</short>
        <descr>Ignores recursive calls.</descr>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetControlClassDefaultSize" link="#lcl.controls.TControl.GetControlClassDefaultSize"/>
      <element name="TScrollingWinControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.ScrollBy">
        <short>Tells the widget to scroll the client area relative</short>
        <descr>The still visible part doesn't deserve a repaint (optimization).</descr>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.ScrollBy.DeltaX">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScrollBy.DeltaY">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScrollInView">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.ScrollInView.AControl">
        <short>Control which provides the bounds adjusted in the method</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.HorzScrollBar">
        <short>The horizontal scroll bar (LCL control)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.VertScrollBar">
        <short>The vertical scroll bar (LCL control)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TScrollBox">
        <short>Implements a windowed control with scroll bars</short>
        <descr>
          <p>
            <var>TScrollBox</var> is a <var>TScrollingWinControl</var> descendant that implements a windowed control with scroll bars. TScrollBox sets the visibility for properties inherited from the ancestor class. TScrollBox includes an overridden constructor which sets the default values for properties in the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl"/>
        </seealso>
      </element>
      <element name="TScrollBox.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>
      <element name="TScrollBox.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TScrollBox.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="TScrollBox.Align" link="#lcl.controls.TControl.Align"/>
      <element name="TScrollBox.Anchors" link="#lcl.controls.TControl.Anchors"/>
      <element name="TScrollBox.AutoSize" link="#lcl.controls.TControl.AutoSize"/>
      <element name="TScrollBox.AutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <element name="TScrollBox.BorderSpacing" link="#lcl.controls.TControl.BorderSpacing"/>
      <element name="TScrollBox.BiDiMode" link="#lcl.controls.TControl.BiDiMode"/>
      <element name="TScrollBox.BorderStyle" link="#lcl.controls.TWinControl.BorderStyle"/>
      <element name="TScrollBox.ChildSizing" link="#lcl.controls.TWinControl.ChildSizing"/>
      <element name="TScrollBox.ClientHeight" link="#lcl.controls.TControl.ClientHeight"/>
      <element name="TScrollBox.ClientWidth" link="#lcl.controls.TControl.ClientWidth"/>
      <element name="TScrollBox.Constraints" link="#lcl.controls.TControl.Constraints"/>
      <element name="TScrollBox.DockSite" link="#lcl.controls.TWinControl.DockSite"/>
      <element name="TScrollBox.DragCursor" link="#lcl.controls.TControl.DragCursor"/>
      <element name="TScrollBox.DragKind" link="#lcl.controls.TControl.DragKind"/>
      <element name="TScrollBox.DragMode" link="#lcl.controls.TControl.DragMode"/>
      <element name="TScrollBox.Enabled" link="#lcl.controls.TControl.Enabled"/>
      <element name="TScrollBox.Color" link="#lcl.controls.TControl.Color"/>
      <element name="TScrollBox.Font" link="#lcl.controls.TControl.Font"/>
      <element name="TScrollBox.ParentBackground" link="#lcl.controls.TControl.ParentBackground"/>
      <element name="TScrollBox.ParentBiDiMode" link="#lcl.controls.TControl.ParentBiDiMode"/>
      <element name="TScrollBox.ParentColor" link="#lcl.controls.TControl.ParentColor"/>
      <element name="TScrollBox.ParentFont" link="#lcl.controls.TControl.ParentFont"/>
      <element name="TScrollBox.ParentShowHint" link="#lcl.controls.TControl.ParentShowHint"/>
      <element name="TScrollBox.PopupMenu" link="#lcl.controls.TControl.PopupMenu"/>
      <element name="TScrollBox.ShowHint" link="#lcl.controls.TControl.ShowHint"/>
      <element name="TScrollBox.TabOrder" link="#lcl.controls.TWinControl.TabOrder"/>
      <element name="TScrollBox.TabStop" link="#lcl.controls.TWinControl.TabStop"/>
      <element name="TScrollBox.Visible" link="#lcl.controls.TControl.Visible"/>
      <element name="TScrollBox.OnClick" link="#lcl.controls.TControl.OnClick"/>
      <element name="TScrollBox.OnConstrainedResize" link="#lcl.controls.TControl.OnConstrainedResize"/>
      <element name="TScrollBox.OnDblClick" link="#lcl.controls.TControl.OnDblClick"/>
      <element name="TScrollBox.OnDockDrop" link="#lcl.controls.TWinControl.OnDockDrop"/>
      <element name="TScrollBox.OnDockOver" link="#lcl.controls.TWinControl.OnDockOver"/>
      <element name="TScrollBox.OnDragDrop" link="#lcl.controls.TControl.OnDragDrop"/>
      <element name="TScrollBox.OnDragOver" link="#lcl.controls.TControl.OnDragOver"/>
      <element name="TScrollBox.OnEndDock" link="#lcl.controls.TControl.OnEndDock"/>
      <element name="TScrollBox.OnEndDrag" link="#lcl.controls.TControl.OnEndDrag"/>
      <element name="TScrollBox.OnEnter" link="#lcl.controls.TWinControl.OnEnter"/>
      <element name="TScrollBox.OnExit" link="#lcl.controls.TWinControl.OnExit"/>
      <element name="TScrollBox.OnGetSiteInfo" link="#lcl.controls.TWinControl.OnGetSiteInfo"/>
      <element name="TScrollBox.OnMouseDown" link="#lcl.controls.TControl.OnMouseDown"/>
      <element name="TScrollBox.OnMouseEnter" link="#lcl.controls.TControl.OnMouseEnter"/>
      <element name="TScrollBox.OnMouseLeave" link="#lcl.controls.TControl.OnMouseLeave"/>
      <element name="TScrollBox.OnMouseMove" link="#lcl.controls.TControl.OnMouseMove"/>
      <element name="TScrollBox.OnMouseUp" link="#lcl.controls.TControl.OnMouseUp"/>
      <element name="TScrollBox.OnMouseWheel" link="#lcl.controls.TControl.OnMouseWheel"/>
      <element name="TScrollBox.OnMouseWheelDown" link="#lcl.controls.TControl.OnMouseWheelDown"/>
      <element name="TScrollBox.OnMouseWheelUp" link="#lcl.controls.TControl.OnMouseWheelUp"/>
      <element name="TScrollBox.OnMouseWheelHorz" link="#lcl.controls.TControl.OnMouseWheelHorz"/>
      <element name="TScrollBox.OnMouseWheelLeft" link="#lcl.controls.TControl.OnMouseWheelLeft"/>
      <element name="TScrollBox.OnMouseWheelRight" link="#lcl.controls.TControl.OnMouseWheelRight"/>
      <element name="TScrollBox.OnResize" link="#lcl.controls.TControl.OnResize"/>
      <element name="TScrollBox.OnStartDock" link="#lcl.controls.TControl.OnStartDock"/>
      <element name="TScrollBox.OnStartDrag" link="#lcl.controls.TControl.OnStartDrag"/>
      <element name="TScrollBox.OnUnDock" link="#lcl.controls.TWinControl.OnUnDock"/>
      <element name="TScrollBox.OnPaint" link="#lcl.controls.TCustomControl.OnPaint"/>
      <element name="TCustomDesignControl">
        <short>Provides a designer surface for scaling and layout of its child controls</short>
        <descr>
          <p>
            <var>TCustomDesignControl</var> is a <var>TScrollingWinControl</var> descendant which provides a designer surface used for scaling and layout of its child controls.
          </p>
          <p>
            Properties are provided to set the display density (Pixels Per Inch) for design-time and run-time usage, and to Scale child controls. Methods are also provided to use <var>TLayoutAdjustmentPolicy</var> to layout and to re-size the child controls.
          </p>
          <p>
            An overridden <var>Loaded</var> method is provided to adjust the design-time PPI (when scaling is enabled in the application).
          </p>
          <p>
            TCustomDesignControl is used as the ancestor for <var>TCustomFrame</var> and <var>TCustomForm</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.Scaled"/>
          <link id="TCustomForm"/>
          <link id="TCustomFrame"/>
          <link id="GetParentDesignControl"/>
          <link id="NeedParentDesignControl"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.FScaled"/>
      <element name="TCustomDesignControl.FDesignTimePPI"/>
      <element name="TCustomDesignControl.FPixelsPerInch"/>
      <element name="TCustomDesignControl.DesignTimePPIIsStored">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDesignControl.DesignTimePPIIsStored.Result">
        <short/>
      </element>
      <element name="TCustomDesignControl.SetDesignTimePPI">
        <short>Sets the value for the DesignTimePPI property</short>
        <descr/>
        <seealso>
          <link id="TCustomDesignControl.DesignTimePPI"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.SetDesignTimePPI.ADesignTimePPI">
        <short>New value for the property</short>
      </element>
      <element name="TCustomDesignControl.SetScaled">
        <short>Sets the value for the Scaled property</short>
        <descr/>
        <seealso>
          <link id="TCustomDesignControl.Scaled"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.SetScaled.AScaled">
        <short>New value for the property</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout">
        <short>
          Applies size and layout changes to the design surface and its Parent control
        </short>
        <descr>
          <p>
            <var>DoAutoAdjustLayout</var> is a procedure used to perform actions needed to apply size and layout changes to the design surface and its <var>Parent</var> control.
          </p>
          <p>
            <var>DoAutoAdjustLayout</var> adjusts the height and width for the design surface by the specified scaling factors. Similarly, the <var>BorderSpacing</var> and <var>Constraints</var> in the control are adjusted using the scaling factors. Finally, the <var>SetBounds</var> method is called to apply the new values for Height and Width to the design surface.
          </p>
          <remark>
            No actions are performed in the method when the Parent property has not been assigned (contains <b>Nil</b>). In addition, no actions are performed when <var>AMode</var> omits the <var>lapAutoAdjustWithoutHorizontalScrolling</var> and <var>lapAutoAdjustForDPI</var>  enumeration values.
          </remark>
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.AutoAdjustLayout">TControl.AutoAdjustLayout</link>
          <link id="#lcl.controls.TControl.Constraints">TControl.Constraints</link>
          <link id="#lcl.controls.TControl.BorderSpacing">TControl.BorderSpacing</link>
          <link id="#lcl.controls.TControl.Parent">TControl.Parent</link>
          <link id="#lcl.controls.TLayoutAdjustmentPolicy"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AMode">
        <short>TLayoutAdjustmentPolicy applied in the method</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AXProportion">
        <short>Horizontal scaling factor applied in the method</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AYProportion">
        <short>Vertical scaling factor applied in the method</short>
      </element>
      <element name="TCustomDesignControl.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited method using the value in <var>TheOwner</var> as the the owner of the class instance. Create sets the default values for the following properties:
          </p>
          <ul>
            <li>Scaled</li>
            <li>DesignTimePPI</li>
            <li>PixelsPerInch</li>
          </ul>
          <p>
            When scaling is enabled in the Application, the value in <var>DesignTimePPI</var> is used as the <var>PixelsPerInch</var> setting in the <var>Font</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TApplication.Scaled"/>
          <link id="#lcl.controls.TControl.Font">TControl.Font</link>
        </seealso>
      </element>
      <element name="TCustomDesignControl.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout">
        <short>
          Applies a new display density (Pixels Per Inch) for a layout policy to the control
        </short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is used to set the value in the <var>PixelsPerInch</var> property to the value specified in <var>AToPPI</var> for the <var>lapAutoAdjustForDPI</var> layout policy. AutoAdjustLayout calls the inherited method.
          </p>
          <remark>
            No additional actions are performed in the method when <var>AMode</var> contains a value other than <var>lapAutoAdjustForDPI</var>.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.DoAutoAdjustLayout"/>
          <link id="TLayoutAdjustmentPolicy"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AMode">
        <short>Layout policy to use for the design surface</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AFromPPI">
        <short>Original display density setting</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AToPPI">
        <short>New display density setting</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AOldFormWidth">
        <short>Original form width</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.ANewFormWidth">
        <short>New form width</short>
      </element>
      <element name="TCustomDesignControl.DesignTimePPI">
        <short>Design-time Pixels Per Inch for the designer surface</short>
        <descr>
          <p>
            <var>DesignTimePPI</var> is an <var>Integer</var> property that contains the display density (or Pixels Per Inch) used on the designer surface. The default value for the property is <b>96</b>.
          </p>
          <p>
            The property value is normally set when the component is loaded using the LCL streaming mechanism. It can be assigned at design-time to the value in <var>ADesignTimePPI</var> only when the new value matches the display density for the current Screen where the designer surface is used. The value can be changed at run-time, but the programmer must ensure that the value is valid for the intended usage.
          </p>
          <p>
            An <var>EInvalidOperation</var> exception is raised if an invalid value is specified at design-time.
          </p>
          <p>
            When scaling is enabled in the Application, the value in DesignTimePPI is assigned to the <var>Font</var> for the designer surface.
          </p>
          <p>
            Use <var>PixelsPerInch</var> to access the run-time display density for the designer surface.
          </p>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TApplication.Scaled"/>
          <link id="#lcl.controls.TControl.Font">TControl.Font</link>
        </seealso>
      </element>
      <element name="TCustomDesignControl.PixelsPerInch">
        <short>Run-time Pixels Per Inch for the designer surface</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDesignControl.Scaled">
        <short>
          Indicates if the design surface is scaled to reflect changes in display density (Pixels Per Inch)
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomFrame">
        <short>The base type for <var>TFrame</var></short>
        <descr>
          <p>
            <var>TCustomFrame</var> is a <var>TCustomDesignControl</var> descendant which implements the base class for <var>TFrame</var>.  A Frame is a named container for related components. Groups of  controls can be place on a frame, and re-used in your applications.
          </p>
          <p>
            A Frame has behavior very similar to a Form. Their unique ability is that they can be embedded into forms or other frames in the designer.  Like forms, they are stored in two separate files: the code is stored in a .pas unit file, and the design is stored in a .lfm file.
          </p>
          <p>
            Frames can be created and designed in the Lazarus IDE by creating a new Frame module, and using the unit in your application. An existing frame can be added using the TFrame component on the Standard tab in the Lazarus IDE; you will be prompted for the TFrame class to use for the component.
          </p>
          <p>
            Frames can also be created entirely in code at run-time. They do not have to be installed in the Lazarus IDE. One drawback is that complex inheritance hierarchies for <var>TFrame</var> classes can be problematic; they do not propagate changes to all derived frames in a multi-level inheritance tree.
          </p>
        </descr>
        <seealso>
          <link id="TFrame"/>
          <link id="TCustomDesignControl"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.AddActionList">
        <short>Adds the specified list of Actions to the Parent form for the frame class</short>
        <descr>
          <remark>
            Please note: No actions are performed in the method when a Parent form has not been assigned for the class instance.
          </remark>
        </descr>
        <seealso>
          <link id="GetParentForm"/>
        </seealso>
      </element>
      <element name="TCustomFrame.AddActionList.ActionList">
        <short>List of Actions added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.RemoveActionList">
        <short>Removes the specified list of Actions from the Parent form</short>
        <descr>
          <remark>
            Please note: No actions are performed in the method when a Parent form has not been assigned for the class instance.
          </remark>
        </descr>
        <seealso>
          <link id="GetParentForm"/>
        </seealso>
      </element>
      <element name="TCustomFrame.RemoveActionList.ActionList">
        <short>List of Actions removed in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.ReadDesignLeft">
        <short>Implements reading the Left property for the designer surface</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomFrame.ReadDesignLeft.Reader">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.ReadDesignTop">
        <short>Implements reading the Right property for the designer surface</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomFrame.ReadDesignTop.Reader">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.WriteDesignLeft">
        <short>Implements writing the Left property for the designer surface</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomFrame.WriteDesignLeft.Writer">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.WriteDesignTop">
        <short>Implements writing the Top property for the designer surface</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomFrame.WriteDesignTop.Writer">
        <short/>
      </element>
      <element name="TCustomFrame.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.GetChildren">
        <short>
          Invokes <var>Proc</var> for all Controls and also for all Components without a Parent
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.GetChildren">TWinControl.GetChildren</link>
        </seealso>
      </element>
      <element name="TCustomFrame.GetChildren.Proc">
        <short>The callback method</short>
      </element>
      <element name="TCustomFrame.GetChildren.Root">
        <short>Components are enumerated only if Root=Self</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.Notification">
        <short>Also handles add/remove of ActionLists</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification">TComponent.Notification</link>
          <link id="#LCL.Controls.TControl.Notification">TControl.Notification</link>
        </seealso>
      </element>
      <element name="TCustomFrame.Notification.AComponent">
        <short>Component for the notification</short>
      </element>
      <element name="TCustomFrame.Notification.Operation">
        <short>Operation for the notification</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.SetParent">
        <short>Sets the value for the Parent property</short>
        <descr>
          Also updates the ActionLists, and performs automatic layout adjustments when needed.
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.Parent">TControl.Parent</link>
          <link id="#lcl.controls.TControl.SetParent">TControl.SetParent</link>
        </seealso>
      </element>
      <element name="TCustomFrame.SetParent.AParent">
        <short>Value assigned to the Parent property</short>
      </element>
      <element name="TCustomFrame.DefineProperties" link="#rtl.classes.TComponent.DefineProperties"/>
      <element name="TCustomFrame.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.CalculatePreferredSize" link="#lcl.controls.TControl.CalculatePreferredSize"/>
      <element name="TCustomFrame.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomFrame.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomFrame.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomFrame.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited method using AOwner as the owner for the class instance. Create sets the ControlStyle property to the following enumeration values:
          </p>
          <ul>
            <li>csAcceptsControls</li>
            <li>csCaptureMouse</li>
            <li>csClickEvents</li>
            <li>csSetCaption</li>
            <li>csDoubleClicks</li>
            <li>csParentBackground</li>
          </ul>
          <p>
            Create uses the default size for its class type to set the initial bounds for the control.
          </p>
        </descr>
        <errors>
          Raises an EResNotFound exception at run-time if the ClassType for the class instance
          is not derived from TFrame.
        </errors>
        <seealso>
          <link id="#rtl.classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <element name="TCustomFrame.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomFrame.GetControlClassDefaultSize" link="#lcl.controls.TControl.GetControlClassDefaultSize"/>
      <element name="TCustomFrame.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TCustomFrameClass" link="#lcl.forms.TCustomFrame"/>
      <!-- object Visibility: default -->
      <element name="TFrame">
        <short>
          Frames can be designed like Forms and used like custom controls, without much coding or installation in the IDE.
        </short>
        <descr>
          <p>
            <var>TFrame</var> is a <var>TCustomFrame</var> descendant which implements a named container for related components. Groups of  controls can be place on a frame, and re-used in your applications.
          </p>
          <p>
            A Frame has behavior very similar to a Form. Their unique ability is that they can be embedded into forms or other frames in the designer.  Like forms, they are stored in two separate files: the code is stored in a .pas unit file, and the design is stored in a .lfm file.
          </p>
          <p>
            Frames can be created and designed in the Lazarus IDE by creating a new Frame module, and using the unit in your application. An existing frame can be added using the TFrame component on the Standard tab in the Lazarus IDE; you will be prompted for the TFrame class to use for the component.
          </p>
          <p>
            Frames can also be created entirely in code at run-time. They do not have to be installed in the Lazarus IDE. One drawback is that complex inheritance hierarchies for <var>TFrame</var> classes can be problematic; they do not propagate changes to all derived frames in the entire inheritance tree.
          </p>
          <p>
            TFrame contains a new property which indicates the LCL (Lazarus Component Library) version number used in the container. An overridden constructor is also introduced to initialize the value in the LCLVersion property. TFrame sets the visibility for properties defines in ancestor classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TFrame.FLCLVersion" link="#lcl.forms.TFrame.LCLVersion"/>
      <element name="TFrame.LCLVersionIsStored" link="#lcl.forms.TFrame.LCLVersion"/>
      <element name="TFrame.LCLVersionIsStored.Result">
        <short/>
      </element>
      <element name="TFrame.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TFrame.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="TFrame.Align" link="#lcl.controls.TControl.Align"/>
      <element name="TFrame.Anchors" link="#lcl.controls.TControl.Anchors"/>
      <element name="TFrame.AutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <element name="TFrame.AutoSize" link="#lcl.controls.TControl.AutoSize"/>
      <element name="TFrame.BiDiMode" link="#lcl.controls.TControl.BiDiMode"/>
      <element name="TFrame.BorderSpacing" link="#lcl.controls.TControl.BorderSpacing"/>
      <element name="TFrame.ChildSizing" link="#lcl.controls.TWinControl.ChildSizing"/>
      <element name="TFrame.ClientHeight" link="#lcl.controls.TControl.ClientHeight"/>
      <element name="TFrame.ClientWidth" link="#lcl.controls.TControl.ClientWidth"/>
      <element name="TFrame.Color" link="#lcl.controls.TControl.Color"/>
      <element name="TFrame.Constraints" link="#lcl.controls.TControl.Constraints"/>
      <element name="TFrame.DockSite" link="#lcl.controls.TWinControl.DockSite"/>
      <element name="TFrame.DragCursor" link="#lcl.controls.TControl.DragCursor"/>
      <element name="TFrame.DragKind" link="#lcl.controls.TControl.DragKind"/>
      <element name="TFrame.DragMode" link="#lcl.controls.TControl.DragMode"/>
      <element name="TFrame.Enabled" link="#lcl.controls.TControl.Enabled"/>
      <element name="TFrame.Font" link="#lcl.controls.TControl.Font"/>
      <element name="TFrame.LCLVersion" link="#lcl.lclversion.lcl_version"/>
      <element name="TFrame.OnClick" link="#lcl.controls.TControl.OnClick"/>
      <element name="TFrame.OnConstrainedResize" link="#lcl.controls.TControl.OnConstrainedResize"/>
      <element name="TFrame.OnContextPopup" link="#lcl.controls.TControl.OnContextPopup"/>
      <element name="TFrame.OnDblClick" link="#lcl.controls.TControl.OnDblClick"/>
      <element name="TFrame.OnDockDrop" link="#lcl.controls.TWinControl.OnDockDrop"/>
      <element name="TFrame.OnDockOver" link="#lcl.controls.TWinControl.OnDockOver"/>
      <element name="TFrame.OnDragDrop" link="#lcl.controls.TControl.OnDragDrop"/>
      <element name="TFrame.OnDragOver" link="#lcl.controls.TControl.OnDragOver"/>
      <element name="TFrame.OnEndDock" link="#lcl.controls.TControl.OnEndDock"/>
      <element name="TFrame.OnEndDrag" link="#lcl.controls.TControl.OnEndDrag"/>
      <element name="TFrame.OnEnter" link="#lcl.controls.TWinControl.OnEnter"/>
      <element name="TFrame.OnExit" link="#lcl.controls.TWinControl.OnExit"/>
      <element name="TFrame.OnGetSiteInfo" link="#lcl.controls.TWinControl.OnGetSiteInfo"/>
      <element name="TFrame.OnMouseDown" link="#lcl.controls.TControl.OnMouseDown"/>
      <element name="TFrame.OnMouseEnter" link="#lcl.controls.TControl.OnMouseEnter"/>
      <element name="TFrame.OnMouseLeave" link="#lcl.controls.TControl.OnMouseLeave"/>
      <element name="TFrame.OnMouseMove" link="#lcl.controls.TControl.OnMouseMove"/>
      <element name="TFrame.OnMouseUp" link="#lcl.controls.TControl.OnMouseUp"/>
      <element name="TFrame.OnMouseWheel" link="#lcl.controls.TControl.OnMouseWheel"/>
      <element name="TFrame.OnMouseWheelDown" link="#lcl.controls.TControl.OnMouseWheelDown"/>
      <element name="TFrame.OnMouseWheelUp" link="#lcl.controls.TControl.OnMouseWheelUp"/>
      <element name="TFrame.OnResize" link="#lcl.controls.TControl.OnResize"/>
      <element name="TFrame.OnStartDock" link="#lcl.controls.TControl.OnStartDock"/>
      <element name="TFrame.OnStartDrag" link="#lcl.controls.TControl.OnStartDrag"/>
      <element name="TFrame.OnUnDock" link="#lcl.controls.TWinControl.OnUnDock"/>
      <element name="TFrame.ParentBiDiMode" link="#lcl.controls.TControl.ParentBiDiMode"/>
      <element name="TFrame.ParentColor" link="#lcl.controls.TControl.ParentColor"/>
      <element name="TFrame.ParentFont" link="#lcl.controls.TControl.ParentFont"/>
      <element name="TFrame.ParentShowHint" link="#lcl.controls.TControl.ParentShowHint"/>
      <element name="TFrame.PopupMenu" link="#lcl.controls.TControl.PopupMenu"/>
      <element name="TFrame.ShowHint" link="#lcl.controls.TControl.ShowHint"/>
      <element name="TFrame.TabOrder" link="#lcl.controls.TWinControl.TabOrder"/>
      <element name="TFrame.TabStop" link="#lcl.controls.TWinControl.TabStop"/>
      <element name="TFrame.Visible" link="#lcl.controls.TControl.Visible"/>

      <element name="TBorderIcon">
        <short>
          Represents a visual element in a window title bar; depends on window manager support
        </short>
        <descr>
          <dl>
            <dt>biSystemMenu</dt>
            <dd>The form has a System menu (Maybe not all windowmanager supports this)</dd>
            <dt>biMinimize</dt>
            <dd>The form has an minimize button</dd>
            <dt>biMaximize</dt>
            <dd>The form has a maximize button</dd>
            <dt>biHelp</dt>
            <dd>When you click this button a Question Cursor appears, and the help routines are
              called if you click on an control</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TBorderIcon.biSystemMenu">
        <short>Window has a system menu</short>
      </element>
      <element name="TBorderIcon.biMinimize">
        <short>Window has an Minimize button</short>
      </element>
      <element name="TBorderIcon.biMaximize">
        <short>Window has an Maximize button</short>
      </element>
      <element name="TBorderIcon.biHelp">
        <short>Window has an Help button</short>
      </element>
      <element name="TBorderIcons" link="#lcl.forms.TBorderIcon"/>
      <element name="TDefaultMonitor">
        <short>The preferred monitor for showing a form</short>
        <descr>
          <p>
            When a form is not assigned to a specific monitor, assume the following display context:
          </p>
          <dl>
            <dt>dmDesktop</dt>
            <dd>No attempt to choose specific monitor</dd>
            <dt>dmPrimary</dt>
            <dd>On the primary monitor</dd>
            <dt>dmMainForm</dt>
            <dd>On the same monitor as the main form; if there is no main form then use
              dmPrimary behavior</dd>
            <dt>dmActiveForm</dt>
            <dd>On the same monitor as the currently active form; if there is no active form
              then use dmMainForm behavior</dd>
          </dl>
        </descr>
      </element>
      <element name="TDefaultMonitor.dmDesktop">
        <short>Place the form on the full desktop</short>
      </element>
      <element name="TDefaultMonitor.dmPrimary">
        <short>Place the form on the primary monitor</short>
      </element>
      <element name="TDefaultMonitor.dmMainForm">
        <short>
          Place the form on the same monitor as the main form. If there is no such form then use the primary monitor.
        </short>
      </element>
      <element name="TDefaultMonitor.dmActiveForm">
        <short>
          Place the form on the same monitor as the currently active form. If there is no such form then use the primary monitor.
        </short>
      </element>
      <element name="TFormStateType">
        <short>Form state flags</short>
        <descr>
          <p>The form states are:</p>
          <dl>
            <dt>fsCreating</dt>
            <dd>initializing (form streaming)</dd>
            <dt>fsVisible</dt>
            <dd>form should be shown</dd>
            <dt>fsShowing</dt>
            <dd>form handling WM_SHOWWINDOW message</dd>
            <dt>fsModal</dt>
            <dd>form is modal</dd>
            <dt>fsCreatedMDIChild</dt>
            <dd>not yet implemented</dd>
            <dt>fsBorderStyleChanged</dt>
            <dd>border style changed before window handle creation</dd>
            <dt>fsFormStyleChanged</dt>
            <dd>form style is changed before window handle creation</dd>
            <dt>fsFirstShow</dt>
            <dd>form is shown for the first time</dd>
            <dt>fsDisableAutoSize</dt>
            <dd>disable autosize</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TFormStateType.fsCreating">
        <short>initializing (form streaming)</short>
      </element>
      <element name="TFormStateType.fsVisible">
        <short>form should be shown</short>
      </element>
      <element name="TFormStateType.fsShowing">
        <short>form handling WM_SHOWWINDOW message</short>
      </element>
      <element name="TFormStateType.fsModal">
        <short>form is modal</short>
      </element>
      <element name="TFormStateType.fsCreatedMDIChild">
        <short>not yet implemented</short>
      </element>
      <element name="TFormStateType.fsBorderStyleChanged">
        <short>border style changed before window handle creation</short>
      </element>
      <element name="TFormStateType.fsFormStyleChanged">
        <short>form style is changed before window handle creation</short>
      </element>
      <element name="TFormStateType.fsFirstShow">
        <short>form is shown for the first time</short>
      </element>
      <element name="TFormStateType.fsDisableAutoSize">
        <short>disable autosize</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TFormState" link="#lcl.forms.TFormStateType">
        <short>The set of form state flags</short>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TModalResult" link="#lcl.uitypes.TModalResult">
        <short>Dummy type for the values that can be returned as a modal result</short>
        <descr>
          <p>
            Even though the type is defined as an integer, only the defined constant values should be used (mrOK, mrCancel, et. al.).
          </p>
        </descr>
        <seealso>
          <link id="controls.mrNone"/>
          <link id="controls.mrOK"/>
          <link id="controls.mrCancel"/>
          <link id="controls.mrAbort"/>
          <link id="controls.mrRetry"/>
          <link id="controls.mrIgnore"/>
          <link id="controls.mrYes"/>
          <link id="controls.mrNo"/>
          <link id="controls.mrAll"/>
        </seealso>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PModalResult" link="#lcl.forms.TModalResult"/>
      <!-- enumeration type Visibility: default -->
      <element name="TFormHandlerType">
        <short>TForm Notification handler types</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormHandlerType.fhtFirstShow">
        <short>Notified on first form Show</short>
      </element>
      <element name="TFormHandlerType.fhtClose">
        <short>Notified on form Close</short>
      </element>
      <element name="TFormHandlerType.fhtCreate">
        <short>Notified after form Create</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TShowInTaskbar">
        <short>How a form is represented in the TaskBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TShowInTaskbar.stDefault">
        <short>
          Uses the default rules from the platform for showing the form in the TaskBar
        </short>
      </element>
      <element name="TShowInTaskbar.stAlways">
        <short>Always show the form in the TaskBar</short>
      </element>
      <element name="TShowInTaskbar.stNever">
        <short>Never show the form in the TaskBar</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPopupMode">
        <short>Defines the handling performed for a parent window in forms and dialogs</short>
        <descr>
          <p>
            <var>TPopupMode</var> is an enumerated type with values that specify how the parent is determined for a form or dialog. <var>TPopupMode</var> is the type used for the <var>PopupMode</var> property in <var>TCustomForm</var>.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.PopupMode"/>
          <link id="TCustomForm.PopupParent"/>
          <link id="TCustomForm.GetRealPopupParent"/>
        </seealso>
      </element>
      <element name="TPopupMode.pmNone">
        <short>
          modal: popup to active form or if not available, to main form; non-modal: no window parent
        </short>
      <descr>
        <p>
          For modal windows, the handle has to be recreated in ShowModal. If this is not wanted, please use explicitly pmAuto before calling ShowModal.
        </p>
      </descr>
      </element>
      <element name="TPopupMode.pmAuto">
        <short>
          modal and non-modal: popup to active form or if not available, to main form
        </short>
      </element>
      <element name="TPopupMode.pmExplicit">
        <short>
          modal and non-modal: popup to PopupParent or if not available, to main form
        </short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TCloseEvent">
        <short>Type used for an OnClose event handler in a form</short>
        <descr>
          <p>Closing a form can have several meanings:</p>
          <dl>
            <dt>caNone</dt>
            <dd>Do nothing (don't close).</dd>
            <dt>caHide</dt>
            <dd>Hide the form (default for modal forms).</dd>
            <dt>caFree</dt>
            <dd>Destroy the form.</dd>
            <dt>caMinimize</dt>
            <dd>Minimize the form (MDI child default).</dd>
          </dl>
          <p>The handler can set CloseAction to the desired value for the action.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TCloseEvent.Sender">
        <short>The form that received an Close request</short>
      </element>
      <element name="TCloseEvent.CloseAction">
        <short>Set this to caNone, to prevent the form from closing</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TCloseQueryEvent">
        <short>Specifies an OnCloseQuery handler event handler</short>
        <descr>
          <p>
            <var>TCloseQueryEvent</var> is an object procedure type which specifies the event handler signalled to determine if a form can be closed.
          </p>
          <p>
            TCloseQueryEvent is the type used to implement the <var>OnCloseQuery</var> property in <var>TCustomForm</var>. An application must implement an object procedure using the signature for the event handler to allow responding to the notification.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnCloseQuery"/>
        </seealso>
      </element>
      <element name="TCloseQueryEvent.Sender">
        <short>The form that received an Close request</short>
      </element>
      <element name="TCloseQueryEvent.CanClose">
        <short>Set to False to deny closing</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDropFilesEvent">
        <short>Type used for an OnDropFiles event handler</short>
        <descr>
          <p>
            <var>TDropFilesEvent</var> is an object procedure which specifies an event handler triggered when files are dropped on a drag and drop-enabled control.
          </p>
          <p>
            <var>TDropFilesEvent</var> is the type used to implement the <var>OnDropFiles</var> property in <var>TCustomForm</var> and <var>TApplication</var>. Applications must implement a procedure using the signature for the event handler, and assign it to the property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
          <link id="TApplication.OnDropFiles"/>
          <link id="TApplicationProperties.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TDropFilesEvent.Sender">
        <short>The control that received the dropped files</short>
      </element>
      <element name="TDropFilesEvent.FileNames">
        <short>The list of the dropped files</short>
      </element>
      <!-- function type Visibility: default -->
      <element name="THelpEvent">
        <short>Type used for an OnHelp event handler</short>
        <descr>
          <p>
            <var>THelpEvent</var> is an object function which specifies an event handler signalled when Help is requested in an application or form. <var>THelpEvent</var> is the type used to implement the <var>OnHelp</var> event handler in <var>TCustomForm</var> and <var>TApplication</var>. Applications must implement a function using the signature for the event handler, and assign it to the property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnHelp"/>
          <link id="TApplication.OnHelp"/>
          <link id="TApplicationProperties.OnHelp"/>
        </seealso>
      </element>
      <element name="THelpEvent.Result">
        <short>
          Indicates if the help request is satisfied by the event handler; False causes the default help handler for the application to be used
        </short>
      </element>
      <element name="THelpEvent.Command">
        <short>Help command type requested; either HELP_CONTEXT or HELP_COMMAND</short>
      </element>
      <element name="THelpEvent.Data">
        <short>Context data for the help request</short>
      </element>
      <element name="THelpEvent.CallHelp">
        <short>False suppresses help display</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TShortCutEvent">
        <short>Type used for an OnShortcut event handler</short>
        <descr>
          <p>
            A shortcut handler is invoked when a key is pressed, before any other processing. It can interpret the key as an shortcut and act accordingly. In this case, <var>Handled</var> should be set to <b>True</b> to prevent further processing of the key.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TShortCutEvent.Msg">
        <short>The key event message</short>
      </element>
      <element name="TShortCutEvent.Handled">
        <short>Set Handled to True to prevent further processing of the key</short>
      </element>
      <element name="TModalDialogFinished">
        <short>
          Specifies an event handler signalled when a modal message dialog is completed
        </short>
        <descr>
          <p>
            <var>TModalDialogFinished</var> is an object procedure which specifies an event handler signalled when a modal message dialog is completed. The <var>AResult</var> argument contains the modal result constant returned from the message dialog.
          </p>
          <p>
            <var>TModalDialogFinished</var> is the type used to implement the <var>TCustomForm.OnShowModalFinished</var> and <var>TApplication.OnMessageDialogFinished</var> properties.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnShowModalFinished"/>
          <link id="TApplication.OnMessageDialogFinished"/>
          <link id="TModalResult"/>
        </seealso>
      </element>
      <element name="TModalDialogFinished.Sender">
        <short>TObject instance for the event notification</short>
      </element>
      <element name="TModalDialogFinished.AResult">
        <short>Modal result value from the dialog</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomForm">
        <short>The base type for <var>TForm</var> classes</short>
        <descr>
          <p>
            <var>TCustomForm</var> is a <var>TCustomDesignControl</var> descendant that implements the base type for <var>TForm</var> classes.
          </p>
          <p>
            Forms represent a window or a dialog used as the user interface for a GUI application. It is a container where visual components (such as buttons, labels, edit fields, images, etc.) can be placed. It is also a designer surface which provides design-time support for configuration and layout of the content placed on the form.
          </p>
          <p>
            <var>TCustomForm</var> acts an abstraction layer which masks implementation-specific routines required for the various widget sets supported in the Lazarus Component Library (<b>LCL</b>). Methods and properties are provided which interact with the underlying Operating System or platform, and provide a common API for form-related operations.
          </p>
        </descr>
        <seealso>
          <link id="TForm"/>
          <link id="TCustomDesignControl"/>
        </seealso>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TCustomForm.FActive" link="#lcl.forms.TCustomForm.Active"/>
      <element name="TCustomForm.FActiveControl" link="#lcl.forms.TCustomForm.ActiveControl"/>
      <element name="TCustomForm.FActiveDefaultControl" link="#lcl.forms.TCustomForm.ActiveDefaultControl"/>
      <element name="TCustomForm.FAllowDropFiles" link="#lcl.forms.TCustomForm.AllowDropFiles"/>
      <element name="TCustomForm.FAlphaBlend" link="#lcl.forms.TCustomForm.AlphaBlend"/>
      <element name="TCustomForm.FAlphaBlendValue" link="#lcl.forms.TCustomForm.AlphaBlendValue"/>
      <element name="TCustomForm.FBorderIcons" link="#lcl.forms.TCustomForm.BorderIcons"/>
      <element name="TCustomForm.FDefaultControl" link="#lcl.forms.TCustomForm.DefaultControl"/>
      <element name="TCustomForm.FCancelControl" link="#lcl.forms.TCustomForm.CancelControl"/>
      <element name="TCustomForm.FDefaultMonitor" link="#lcl.forms.TCustomForm.DefaultMonitor"/>
      <element name="TCustomForm.FDesigner" link="#lcl.forms.TCustomForm.Designer"/>
      <element name="TCustomForm.FFormStyle" link="#lcl.forms.TCustomForm.FormStyle"/>
      <element name="TCustomForm.FFormUpdateCount" link="#lcl.forms.TCustomForm.FormIsUpdating"/>
      <element name="TCustomForm.FFormHandlers">
        <short>Lists of installed Form notification handlers</short>
      </element>
      <element name="TCustomForm.FHelpFile" link="#lcl.forms.TCustomForm.HelpFile"/>
      <element name="TCustomForm.FIcon" link="#lcl.forms.TCustomForm.Icon"/>
      <element name="TCustomForm.FOnShowModalFinished" link="#lcl.forms.TCustomForm.OnShowModalFinished"/>
      <element name="TCustomForm.FPopupMode" link="#lcl.forms.TCustomForm.PopupMode"/>
      <element name="TCustomForm.FPopupParent" link="#lcl.forms.TCustomForm.PopupParent"/>
      <element name="TCustomForm.FSmallIconHandle" link="#lcl.forms.TCustomForm.SmallIconHandle"/>
      <element name="TCustomForm.FBigIconHandle" link="#lcl.forms.TCustomForm.BigIconHandle"/>
      <element name="TCustomForm.FKeyPreview" link="#lcl.forms.TCustomForm.KeyPreview"/>
      <element name="TCustomForm.FMenu" link="#lcl.forms.TCustomForm.Menu"/>
      <element name="TCustomForm.FModalResult" link="#lcl.forms.TCustomForm.ModalResult"/>
      <element name="TCustomForm.FLastFocusedControl" link="#lcl.forms.TCustomForm.SetLastFocusedControl">
        <short>Used to track Focus changes (Enter/Exit events)</short>
      </element>
      <element name="TCustomForm.FOldBorderStyle" link="#lcl.forms.TCustomForm.DoDock"/>
      <element name="TCustomForm.FOnActivate" link="#lcl.forms.TCustomForm.OnActivate"/>
      <element name="TCustomForm.FOnClose" link="#lcl.forms.TCustomForm.OnClose"/>
      <element name="TCustomForm.FOnCloseQuery" link="#lcl.forms.TCustomForm.OnCloseQuery"/>
      <element name="TCustomForm.FOnCreate" link="#lcl.forms.TCustomForm.OnCreate"/>
      <element name="TCustomForm.FOnDeactivate" link="#lcl.forms.TCustomForm.OnDeactivate"/>
      <element name="TCustomForm.FOnDestroy" link="#lcl.forms.TCustomForm.OnDestroy"/>
      <element name="TCustomForm.FOnDropFiles" link="#lcl.forms.TCustomForm.OnDropFiles"/>
      <element name="TCustomForm.FOnHelp" link="#lcl.forms.TCustomForm.OnHelp"/>
      <element name="TCustomForm.FOnHide" link="#lcl.forms.TCustomForm.OnHide"/>
      <element name="TCustomForm.FOnShortcut" link="#lcl.forms.TCustomForm.OnShortcut"/>
      <element name="TCustomForm.FOnShow" link="#lcl.forms.TCustomForm.OnShow"/>
      <element name="TCustomForm.FOnWindowStateChange" link="#lcl.forms.TCustomForm.OnWindowStateChange"/>
      <element name="TCustomForm.FPosition" link="#lcl.forms.TCustomForm.Position"/>
      <element name="TCustomForm.FRestoredLeft" link="#lcl.forms.TCustomForm.RestoredLeft"/>
      <element name="TCustomForm.FRestoredTop" link="#lcl.forms.TCustomForm.RestoredTop"/>
      <element name="TCustomForm.FRestoredWidth" link="#lcl.forms.TCustomForm.RestoredWidth"/>
      <element name="TCustomForm.FRestoredHeight" link="#lcl.forms.TCustomForm.RestoredHeight"/>
      <element name="TCustomForm.FShowInTaskbar" link="#lcl.forms.TCustomForm.ShowInTaskBar"/>
      <element name="TCustomForm.FWindowState" link="#lcl.forms.TCustomForm.WindowState"/>
      <element name="TCustomForm.FDelayedEventCtr"/>
      <element name="TCustomForm.FDelayedOnChangeBounds"/>
      <element name="TCustomForm.FDelayedOnResize"/>
      <element name="TCustomForm.FIsFirstOnShow"/>
      <element name="TCustomForm.FIsFirstOnActivate"/>
      <element name="TCustomForm.FIsFirstRestore"/>
      <element name="TCustomForm.FWindowStateChanged"/>
      <element name="TCustomForm.GetClientHandle" link="#lcl.forms.TCustomForm.ClientHandle"/>
      <element name="TCustomForm.GetClientHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetEffectiveShowInTaskBar">
        <short>
          Tries to resolve <var>stDefault</var> in <var>ShowInTaskBar</var> using <var>Application</var> settings.
        </short>
        <descr>
          <p>
            Calls ShowInTaskBar to get the visibility of an icon for the form.
          </p>
          <p>
            When the return value is stDefault (or when called at design-time), the TaskBarBehavior property in Application is taken into consideration to get the actual return value. If the application displays a single button for the executable and its forms, the return value is set to stNever. If multiple buttons can be displayed in the task bar, the value stAlways is used. If the Application uses the value tbDefault, the value stDefault is retained in the return value.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.ShowInTaskBar"/>
          <link id="TApplication.TaskBarBehavior"/>
          <link id="TShowInTaskbar"/>
          <link id="Application"/>
        </seealso>
      </element>
      <element name="TCustomForm.GetEffectiveShowInTaskBar.Result">
        <short>Effect visibility for the form icon in the task bar</short>
      </element>
      <element name="TCustomForm.GetMonitor" link="#lcl.forms.TCustomForm.Monitor">
        <short>Gets the value for the Monitor property</short>
      </element>
      <element name="TCustomForm.GetMonitor.Result">
        <short>Value for the property</short>
      </element>
      <element name="TCustomForm.IsAutoScrollStored" link="#lcl.forms.TCustomForm.AutoScroll"/>
      <element name="TCustomForm.IsAutoScrollStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.IsForm">
        <short>Indicates whether Form properties should be stored in the stream</short>
        <descr>
          <p>
            <var>IsForm</var> is used as the storage specifier for selected properties in the class instance. Always returns <b>True</b> in <var>TCustomForm</var>.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Caption"/>
          <link id="TCustomForm.OnClose"/>
          <link id="TCustomForm.OnCloseQuery"/>
          <link id="TCustomForm.OnResize"/>
          <link id="TCustomForm.IsIconStored"/>
          <link id="TCustomForm.IsAutoScrollStored"/>
        </seealso>
      </element>
      <element name="TCustomForm.IsForm.Result">
        <short>
          True when the value for the various properties should be included in the LCL streaming mechanism
        </short>
      </element>
      <element name="TCustomForm.IsIconStored" link="#lcl.forms.TCustomForm.Icon"/>
      <element name="TCustomForm.IsIconStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.CloseModal">
        <short>Closes a modal form</short>
        <descr>
          <p>
            <var>CloseModal</var> is a procedure which attempts to close a form that has been displayed by calling the <var>ShowModal</var> method.
          </p>
          <p>
            CloseModal calls <var>CloseQuery</var> to determine the action performed in the method. When CloseQuery returns <b>True</b>, the close action is set to <var>caHide</var> and the <var>OnClose</var> event handler is signalled when assigned. Form handlers are notified of the close action.
          </p>
          <p>
            When CloseQuery is <b>False</b>, the close action is used to determine how the request is handled. If the CloseAction is <var>caNone</var>, the value in <var>ModalResult</var> is set to <b>0</b> (<b>zero</b>). If the CloseAction is <var>caFree</var>, the <var>Release</var> method is called to allow the <var>Application</var> to free the form component.
          </p>
          <p>
            If an exception occurs in the method, the value in <var>ModalResult</var> is set to <b>0</b> (<b>zero</b>) and the <var>Application.HandleException</var> method is called.
          </p>
          <remark>
            Please note: <var>CloseModal</var> does not forward the action to the widget set class; that is performed in the <var>ShowModal</var> method to ensure it is executed in the widget set class.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomForm.CloseQuery"/>
          <link id="TCustomForm.OnClose"/>
          <link id="TCustomForm.ModalResult"/>
          <link id="TCustomForm.Release"/>
          <link id="TCustomForm.AddHandler"/>
          <link id="TCustomForm.AddHandlerClose"/>
          <link id="TApplication.HandleException"/>
          <link id="TCloseAction"/>
        </seealso>
      </element>
      <element name="TCustomForm.FreeIconHandles">
        <short>Destroys the form icons</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.IconChanged">
        <short>Loads the new form icons, and notifies the widget set and all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.IconChanged.Sender">
        <short/>
      </element>
      <element name="TCustomForm.DelayedEvent">
        <short>
          Performs actions needed for delayed window move, resize, show, and activate messages
        </short>
        <descr>
          <p>
            <var>DelayedEvent</var> is a mechanism used to reduce the number of move, resize, show, and activate messages that occur for forms and their child controls.
          </p>
          <p>
            <var>DelayedEvent</var> discards duplicate calls to the method; only the most recent message is processed. It is used in conjunction with the <var>QueueAsyncCall</var> method in <var>TApplication</var>. DelayedEvent decrements an internal counter used to track the number of pending delayed event messages. When the counter reaches zero (0), the message is applied.
          </p>
          <p>
            When <var>WindowState</var> is changed to <var>wsNormal</var>, the window origin or size is restored for the delayed event. For delayed <var>OnChangeBounds</var>  and <var>OnChangeBounds</var> messages,  the <var>DoOnShow</var> and/or <var>Activate</var> methods are called when the form is <var>Active</var>. If the form has not already been displayed and activated, the Activate, DoOnResize, or the DoOnChangeBounds method is called for the corresponding delayed message.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
          <link id="TCustomForm.WindowState"/>
          <link id="TCustomForm.WMSize"/>
          <link id="TCustomForm.Activate"/>
          <link id="TCustomForm.DoShow"/>
          <link id="TScrollingWinControl.DoOnResize"/>
          <link id="TControl.DoOnChangeBounds"/>
        </seealso>
      </element>
      <element name="TCustomForm.DelayedEvent.Data">
        <short>
          An integer pointer to the data for the event; not used in the current implementation
        </short>
      </element>
      <element name="TCustomForm.SetActive" link="#lcl.forms.TCustomForm.Active"/>
      <element name="TCustomForm.SetActive.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetActiveControl" link="#lcl.forms.TCustomForm.ActiveControl"/>
      <element name="TCustomForm.SetActiveControl.AWinControl">
        <short/>
      </element>
      <element name="TCustomForm.SetActiveDefaultControl" link="#lcl.forms.TCustomForm.ActiveDefaultControl"/>
      <element name="TCustomForm.SetActiveDefaultControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.SetAllowDropFiles" link="#lcl.forms.TCustomForm.AllowDropFiles"/>
      <element name="TCustomForm.SetAllowDropFiles.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetAlphaBlend" link="#lcl.forms.TCustomForm.AlphaBlend"/>
      <element name="TCustomForm.SetAlphaBlend.AValue">
      <short/>
      </element>
      <element name="TCustomForm.SetAlphaBlendValue" link="#lcl.forms.TCustomForm.AlphaBlendValue"/>
      <element name="TCustomForm.SetAlphaBlendValue.AValue">
      <short/>
      </element>
      <element name="TCustomForm.SetBorderIcons" link="#lcl.forms.TCustomForm.BorderIcons"/>
      <element name="TCustomForm.SetBorderIcons.NewIcons">
        <short/>
      </element>
      <element name="TCustomForm.SetFormBorderStyle" link="#lcl.forms.TCustomForm.BorderStyle"/>
      <element name="TCustomForm.SetFormBorderStyle.NewStyle">
        <short/>
      </element>
      <element name="TCustomForm.SetCancelControl" link="#lcl.forms.TCustomForm.CancelControl"/>
      <element name="TCustomForm.SetCancelControl.NewControl">
        <short/>
      </element>
      <element name="TCustomForm.SetDefaultControl" link="#lcl.forms.TCustomForm.DefaultControl"/>
      <element name="TCustomForm.SetDefaultControl.NewControl">
        <short/>
      </element>
      <element name="TCustomForm.SetFormStyle" link="#lcl.forms.TCustomForm.FormStyle"/>
      <element name="TCustomForm.SetFormStyle.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetIcon" link="#lcl.forms.TCustomForm.Icon"/>
      <element name="TCustomForm.SetIcon.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetMenu" link="#lcl.forms.TCustomForm.Menu"/>
      <element name="TCustomForm.SetMenu.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetModalResult" link="#lcl.forms.TCustomForm.ModalResult"/>
      <element name="TCustomForm.SetModalResult.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPopupMode" link="#lcl.forms.TCustomForm.PopupMode"/>
      <element name="TCustomForm.SetPopupMode.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPopupParent" link="#lcl.forms.TCustomForm.PopupParent"/>
      <element name="TCustomForm.SetPopupParent.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPosition" link="#lcl.forms.TCustomForm.Position"/>
      <element name="TCustomForm.SetPosition.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetShowInTaskbar" link="#lcl.forms.TCustomForm.ShowInTaskBar"/>
      <element name="TCustomForm.SetShowInTaskbar.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetLastFocusedControl">
        <short>Remembers the last focused control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SetLastFocusedControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.SetWindowFocus">
        <short>Called when the Focus changed</short>
        <descr>
          <p>
            <var>SetWindowFocus</var> is a procedure used to ensure that the active control in the form instance has the inpout focus when the forms receives focus. At run-time, the control in <var>ActiveControl</var> (when assigned) is used as the active control. At design-time, the active control is the design surface for the current form instance.
          </p>
          <p>
            No actions are performed in the method when a handle has not been allocated for the active control, or the control cannot be focused.
          </p>
          <p>
            SetWindowFocus calls the <var>SetFocus</var> routine in <file>LCLIntf</file> to change the focus to the handle for the active control, and when successful calls the <var>Perform</var> method in the control to post the <b>CM_UIACTIVATE</b> control message.
          </p>
          <p>
            SetWindowFocus is used in the implementation of the <var>SetFocus</var> and SetActive methods.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.SetFocus"/>
          <link id="TCustomForm.WMActivate"/>
          <link id="TCustomForm.ActiveControl"/>
          <link id="TCustomForm.Active"/>
        </seealso>
      </element>

      <element name="TCustomForm.SetWindowState">
        <short>Sets the value for the WindowState property</short>
        <descr>
          <p>
            SetWindowState sets the value for the WindowState property.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.SetWindowState.Value">
        <short>New value for the property</short>
      </element>

      <element name="TCustomForm.AddHandler">
        <short>Adds a form notification handler with the specified type and code</short>
        <descr>
          <p>
            <var>AddHandler</var> is a procedure used to add a form notification handler to the list of handlers in the form instance.
          </p>
          <p>
            <var>HandlerType</var> is a <var>TFormHandlerType</var> enumeration value that defines the situation(s) where the form handler can be executed. See <link id="TFormHandlerType">TFormHandlerType</link> for more information about values in the enumeration.
          </p>
          <p>
            <var>Handler</var> is a <var>TMethod</var> record with pointers to the code and optional data executed when the handler is invoked.
          </p>
          <p>
            <var>AsFirst</var> indicates if the handler should be inserted as the initial handler in the method list (when <b>True</b>), or appended to the end of the list (when <b>False</b>).
          </p>
          <p>
            AddHandler calls <var>RaiseGDBException</var> to raise an exception when the pointer to the Code in Handler has not been assigned.
          </p>
          <p>
            AddHandler ensures that a <var>TMethodList</var> exists for handlers using the value in HandlerType, and calls the <var>Add</var> method in the <var>TMethodList</var> to store the Handler at the position needed for AsFirst.
          </p>
          <p>
            AddHandler is called from the implementation of more specialized methods like <var>AddHandlerClose</var>, <var>AddHandlerCreate</var>, and <var>AddHandlerFirstShow</var>.
          </p>
        </descr>
        <errors>
          <p>
            Raises a catchable exception if the Code property has not been assigned for the TMethod instance in  Handler. Raised with the message 'TCustomForm.AddHandler'.
          </p>
        </errors>
        <seealso>
          <link id="TCustomForm.AddHandlerClose"/>
          <link id="TCustomForm.AddHandlerCreate"/>
          <link id="TCustomForm.AddHandlerFirstShow"/>
          <link id="TFormHandlerType"/>
          <link id="#lazutils.lazmethodlist.TMethodList">TMethodList</link>
          <link id="#rtl.classes.TMethod">TMethod</link>
        </seealso>
      </element>
      <element name="TCustomForm.AddHandler.HandlerType">
        <short>Form handler type added in the method</short>
      </element>
      <element name="TCustomForm.AddHandler.Handler">
        <short>Code to execute for the form handler</short>
      </element>
      <element name="TCustomForm.AddHandler.AsFirst">
        <short>True if the new form handler becomes the first handler in the list of handlers</short>
      </element>
      <element name="TCustomForm.RemoveHandler">
        <short>Removes a form notification handler of the specified type</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandler.HandlerType">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandler.Handler">
        <short/>
      </element>
      <element name="TCustomForm.FindDefaultForActiveControl">
        <short>Returns the first control in the form Tab order</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.FindDefaultForActiveControl.Result">
        <short/>
      </element>
      <element name="TCustomForm.UpdateMenu">
        <short>Called when the main menu has been changed</short>
        <descr>
          Don't show a main menu for dialog forms, i.e. when BorderStyle=bsDialog
          (Delphi compatible).
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.UpdateShowInTaskBar">
        <short>Notifies the widget set of the change</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMActivate">
        <short>Handles the LM_ACTIVATE message which activates or deactivates the form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMActivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMCloseQuery">
        <short>Handles the LM_CLOSEQUERY message used to close the window</short>
        <descr/>
        <seealso/>
        <notes>
          <note>
            What does Result=0 mean?
            It means that WndProc should ignore the result because the message was already handled.
          </note>
        </notes>
      </element>
      <element name="TCustomForm.WMCloseQuery.message">
        <short/>
      </element>
      <element name="TCustomForm.WMHelp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMHelp.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMShowWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMShowWindow.message">
        <short/>
      </element>
      <element name="TCustomForm.WMSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMSize.message">
        <short/>
      </element>
      <element name="TCustomForm.WMWindowPosChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMWindowPosChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMBiDiModeChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMParentBiDiModeChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMParentBiDiModeChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMAppShowBtnGlyphChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMAppShowBtnGlyphChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMAppShowMenuGlyphChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMAppShowMenuGlyphChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMIconChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMIconChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMRelease">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMRelease.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMActivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMDeactivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMDeactivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMShowingChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMShowingChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMDPIChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMDPIChanged.Msg">
        <short/>
      </element>
      <element name="TCustomForm.FActionLists">
        <short>
          <var>FActionLists</var> is a local variable holding lists of actions associated with the Form
        </short>
      </element>
      <element name="TCustomForm.FFormBorderStyle" link="#lcl.forms.TCustomForm.BorderStyle"/>
      <element name="TCustomForm.FFormState" link="#lcl.forms.TCustomForm.FormState"/>
      <element name="TCustomForm.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>
      <element name="TCustomForm.DoShowWindow">
        <short>
          When a control is not Active, sets the Focus to the first control in the TabOrder for the form
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.Activate">
        <short>Notifies the OnActivate handler</short>
        <descr>
          <p>
            <var>Activate</var> is a procedure used to signal the <var>OnActivate</var> event handler (if  assigned) when the form is activated. Activate is called when the <b>CM_Activate</b> message is handled for the form.
          </p>
          <p>
            Activate uses an internal member to determine whether the form is being displayed for the first time, or following a change of focus between forms. No actions are performed in the method when the form is being displayed for the first time and the <var>WindowState</var> property contains <var>wsMaximized</var> or <var>wsFullScreen</var>.
          </p>
          <p>
            Use <var>OnShow</var> to respond to the event notification performed when the form is displayed for the first time.
          </p>
          <p>
            Use <var>OnChangeBounds</var> or <var>OnResize</var> to respond to delayed changes to the form bounds (position) or resize events.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnActivate"/>
          <link id="TCustomForm.OnShow"/>
          <link id="TCustomForm.OnResize"/>
          <link id="TCustomForm.WindowState"/>
          <link id="#lcl.controls.TControl.OnChangeBounds">TControl.OnChangeBounds</link>
        </seealso>
      </element>
      <element name="TCustomForm.ActiveChanged">
        <short>An empty implementation in TCustomForm</short>
        <descr>
          Can be implemented in a descendant to perform actions needed when the active form is changed.
          Just like Delphi VCL.
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.AdjustClientRect">
        <short>Excludes borders from the given rectangle</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.AdjustClientRect">TWinControl.AdjustClientRect</link>
        </seealso>
      </element>
      <element name="TCustomForm.AdjustClientRect.Rect">
        <short/>
      </element>
      <element name="TCustomForm.BeginFormUpdate">
        <short>Locks form updates (AutoSize), until EndFormUpdate</short>
        <descr>
          Nested calls are allowed (pairs of Begin/EndFormUpdate).
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ColorIsStored" link="#lcl.controls.TControl.Color"/>
      <element name="TCustomForm.ColorIsStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.CreateParams" link="#lcl.controls.TWinControl.CreateParams">
        <short>Initializes parameters used to create the handle for the form instance</short>
        <descr>
          <p>
            <var>CreateParams</var> is used to initialize parameters needed to create the handle for the form instance.
          </p>
          <p>
            CreateParams is an overridden procedure in <var>TCustomForm</var>, and calls the inherited method on entry. CreateParams ensures that values in the <var>Params</var> argument are valid. This includes setting the realized parent form and window handle for a form which is  not the main form in the application. <var>Style</var> flags are also updated to indicate how the form is displayed in the task bar.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.controls.TWinControl.CreateParams">TWinControl.CreateParams</link>
        </seealso>
      </element>
      <element name="TCustomForm.CreateParams.Params">
        <short>Values examined and updated in the method</short>
      </element>
      <element name="TCustomForm.CreateWnd" link="#lcl.controls.TWinControl.CreateWnd">
        <short>Creates the widget, updates the widget-dependent properties.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.CreateWnd">TWinControl.CreateWnd</link>
          <link id="#LCL.Forms.TScrollingWinControl.CreateWnd">TScrollingWinControl.CreateWnd</link>
        </seealso>
      </element>
      <element name="TCustomForm.Deactivate">
        <short>Called when the form looses the focus. Notifies the OnDeactivate handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DoClose">
        <short>Notifies the form close handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtClose"/>
          <link id="TCustomForm.OnClose"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoClose.CloseAction">
        <short/>
      </element>
      <element name="TCustomForm.DoCreate">
        <short>Notifies the form create handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtCreate"/>
          <link id="TCustomForm.OnCreate"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoDestroy">
        <short>Notifies the <link id="TCustomForm.OnDestroy">OnDestroy</link> handler</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnDestroy"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoHide">
        <short>Notifies the <link id="TCustomForm.OnHide">OnHide</link> handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DoShow">
        <short>Notifies the <link id="TCustomForm.OnShow">OnShow</link> handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EndFormUpdate">
        <short>Unlocks form updates; used with BeginFormUpdate</short>
        <descr>
          When the update counter reaches zero, FormEndUpdated is invoked to realize the pending changes.
        </descr>
        <seealso>
          <link id="TCustomForm.BeginFormUpdate"/>
          <link id="#lcl.controls.TWinControl.FormEndUpdated">TWinControl.FormEndUpdated</link>
        </seealso>
      </element>
      <element name="TCustomForm.HandleCreateException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleCreateException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.HandleDestroyException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleDestroyException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.HandleShowHideException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleShowHideException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.InitializeWnd" link="#lcl.controls.TControl.InitializeWnd">
        <short>Initializes the widget, also for AlphaBlend and AllowDropFiles</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.Loaded">
        <short>Also renews ActiveControl and Visible</short>
        <descr/>
        <seealso>
          <link id="TScrollingWinControl.Loaded"/>
          <link id="#rtl.classes.TComponent.Loaded">TComponent.Loaded</link>
        </seealso>
      </element>
      <element name="TCustomForm.ChildHandlesCreated">
        <short>
          Called when handles for child control are created in the form instance
        </short>
        <descr>
          <p>
            ChildHandlesCreated is called after all handles for child controls are created. When this is a top-level form (<var>Parent</var> is Nil),  the ParentFormHandleInitialized method is also called.
          </p>
        </descr>
        <seealso>
          <link id="#LCL.Controls.TWinControl.ChildHandlesCreated">TWinControl.ChildHandlesCreated</link>
        </seealso>
      </element>
      <element name="TCustomForm.Notification" link="#rtl.classes.TComponent.Notification"/>
      <element name="TCustomForm.Notification.AComponent">
        <short/>
      </element>
      <element name="TCustomForm.Notification.Operation">
        <short/>
      </element>
      <element name="TCustomForm.PaintWindow" link="#lcl.controls.TCustomControl.PaintWindow"/>
      <element name="TCustomForm.RequestAlign" link="#lcl.controls.TControl.RequestAlign">
        <short>
          Calls the user Alignment handler (AlignControls). Here: NOP for a top-level form.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.Resizing">
        <short>
          Performs actions needed when the form processes the WMSize message
        </short>
        <descr>
          <p>
            Uses the value in <var>State</var> to determine the action required in the method. The LCL interface is used to determine if the window state is valid for the widget set. When allowed, the following methods are called for the corresponding <var>TWindowState</var> value:
          </p>
          <dl>
            <dt>wsMinimized</dt>
            <dd>Calls the Minimize method in Application, or Restore if the Form is already minimized</dd>
          </dl>
          <p>
            If the value in WindowState has been changed, the method honors the value in the Position property if it was set to maximized  at design-time.
          </p>
          <p>
            When the <var>OnWindowStateChange</var> event handler has been assigned for the form, it is signalled for the current class instance.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl.Resizing"/>
          <link id="TCustomForm.WMSize"/>
          <link id="TScrollingWinControl.WMSize"/>
          <link id="TCustomForm.OnWindowStateChange"/>
        </seealso>
      </element>
      <element name="TCustomForm.Resizing.State">
        <short>Window state applied in the method</short>
      </element>
      <element name="TCustomForm.CalculatePreferredSize" link="#lcl.controls.TControl.CalculatePreferredSize">
        <short>Here: clip width and height of a top-level form to the monitor WorkArea</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <element name="TCustomForm.SetZOrder">
        <short>Here: Moves a top-level form in front or back of all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SetZOrder.Topmost">
        <short>True for BringToFront</short>
      </element>
      <element name="TCustomForm.SetParent" link="#lcl.controls.TControl.Parent"/>
      <element name="TCustomForm.SetParent.NewParent">
        <short/>
      </element>
      <element name="TCustomForm.MoveToDefaultPosition" link="#lcl.forms.TCustomForm.Position">
        <short>Moves the form to its initial Position</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.UpdateShowing">
        <short>
          Called when the widget visibility (Showing) is changed. Updates (and realizes?) all properties affecting the visual representation for the form.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.UpdateShowing">TWinControl.UpdateShowing</link>
        </seealso>
      </element>
      <element name="TCustomForm.SetVisible" link="#lcl.controls.TControl.SetVisible"/>
      <element name="TCustomForm.SetVisible.Value">
        <short>New value for the property</short>
      </element>
      <element name="TCustomForm.AllAutoSized" link="#lcl.controls.TWinControl.AllAutoSized">
        <short>If the the form is about to show, calculate its metrics</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.DoFirstShow">
        <short>Notifies the FirstShow handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtFirstShow"/>
        </seealso>
      </element>
      <element name="TCustomForm.UpdateWindowState">
        <short>UpdateWindowState is an empty implementation in TCustomForm</short>
        <descr/>
        <seealso/>
        <notes><note>An empty implementation in the current LCL version.</note></notes>
      </element>
      <element name="TCustomForm.VisibleChanging">
        <short>Notifies all <var>VisibleChanging</var> handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.VisibleChanged">
        <short>Notifies all <var>VisibleChanged</var> handlers</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreenNotification"/>
        </seealso>
      </element>
      <element name="TCustomForm.WndProc" link="#lcl.controls.TControl.WndProc"/>
      <element name="TCustomForm.WndProc.TheMessage">
        <short>
          Handled messages include: Activate, SetFocus, KillFocus, Exit, Enter, Window Position Changing, and DrawItem
        </short>
      </element>
      <element name="TCustomForm.VisibleIsStored" link="#lcl.forms.TCustomForm.Visible"/>
      <element name="TCustomForm.VisibleIsStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.DoAutoSize" link="#lcl.controls.TControl.DoAutoSize"/>
      <element name="TCustomForm.SetAutoSize" link="#lcl.controls.TControl.AutoSize"/>
      <element name="TCustomForm.SetAutoSize.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetAutoScroll" link="#lcl.forms.TCustomForm.AutoScroll"/>
      <element name="TCustomForm.SetAutoScroll.Value">
        <short/>
      </element>
      <element name="TCustomForm.DoAddActionList">
        <short>Adds the specified list of actions to the ActionList for the form</short>
        <descr>
        </descr>
        <seealso>
          <link id="TCustomForm.DoRemoveActionList"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoAddActionList.List">
        <short/>
      </element>
      <element name="TCustomForm.DoRemoveActionList">
        <short>Removes an ActionList</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="TCustomForm.DoAddActionList"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoRemoveActionList.List">
        <short>List of actions removed in the method</short>
      </element>
      <element name="TCustomForm.ProcessResource">
        <short>Loads resources needed for the form</short>
        <descr>
          Calls InitResourceComponent to load form resources for the current form instance.
        </descr>
        <errors>
          Raises an EResNotFound exception if RequireDerivedFormResource is set for the application, and a resource is not found for the form.
        </errors>
        <seealso/>
      </element>
      <element name="TCustomForm.BeginAutoDrag">
        <short>Checked BeginDrag</short>
        <descr>
          Allow form dragging only if it is docked into a site without a DockManager.
        </descr>
        <seealso/>
        <notes><note>why?</note></notes>
      </element>
      <element name="TCustomForm.DoDock" link="#lcl.controls.TControl.DoDock"/>
      <element name="TCustomForm.DoDock.NewDockSite">
        <short/>
      </element>
      <element name="TCustomForm.DoDock.ARect">
        <short/>
      </element>
      <element name="TCustomForm.GetFloating" link="#lcl.controls.TControl.GetFloating"/>
      <element name="TCustomForm.GetFloating.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetDefaultDockCaption">
        <short>Here: returns the Caption</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.GetDefaultDockCaption.Result">
        <short/>
      </element>
      <element name="TCustomForm.CMActionExecute">
        <short>Handler for ActionExecute messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActionExecute.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMActionUpdate">
        <short>Handler for ActionUpdate messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActionUpdate.Message">
        <short/>
      </element>
      <element name="TCustomForm.DoExecuteAction">
        <short>Asks all applicable components to execute an action</short>
        <descr>
          <p>
            First, the <var>ActiveControl</var> and the <var>Form</var> itself are asked to execute the action. Then, all child components are tried. The search stops as soon as the action is handled.
          </p>
        </descr>
      </element>
      <element name="TCustomForm.DoExecuteAction.Result">
        <short>True when the action was handled</short>
      </element>
      <element name="TCustomForm.DoExecuteAction.ExeAction">
        <short>Action to execute</short>
      </element>
      <element name="TCustomForm.DoUpdateAction">
        <short>Tries all applicable components to update an action</short>
        <descr/>
        <seealso>
          <link id="#LCL.Forms.TCustomForm.DoExecuteAction">DoExecuteAction</link>
        </seealso>
      </element>
      <element name="TCustomForm.DoUpdateAction.Result">
        <short>True when the action was updated</short>
      </element>
      <element name="TCustomForm.DoUpdateAction.TheAction">
        <short/>
      </element>
      <element name="TCustomForm.UpdateActions">
        <short>Asks all components on the form to update their actions</short>
        <descr>
          <p>
            <var>UpdateActions</var> is a procedure used to update actions assigned to components on the form instance. No actions are performed in the method at design-time, or when the <var>Showing</var> property is set to False in the form instance.
          </p>
          <p>
            UpdateActions applies updates for an assigned <var>Menu</var> in the form instance. Items on the Menu update their actions when the menu item is visible. Finally, all controls on the form instance are recursively searched; controls which are action clients update their actions when they are visible.
          </p>
          <p>
            Update actions is called for each of the custom forms when the application enters an idle state, and occurs after processing queued asynchronous calls and the <var>OnIdle</var> event handler in the application.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Visible"/>
          <link id="TCustomForm.Menu"/>
          <link id="TApplication.OnIdle"/>
          <link id="TApplication.Idle"/>
          <link id="#lcl.controls.TWinControl.Showing">TWinControl.Showing</link>
          <link id="#lcl.controls.TControl.InitiateAction">TControl.InitiateAction</link>
        </seealso>
      </element>
      <element name="TCustomForm.ClientHandle">
        <short>The Handle of the MDIForm client (container for MDI children)</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TCustomForm.Create.AOwner">
        <short>Owner for the class instance</short>
      </element>
      <element name="TCustomForm.CreateNew">
        <short>Creates a form without a resource</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CreateNew.AOwner">
        <short>Owner for the new class instance</short>
      </element>
      <element name="TCustomForm.CreateNew.Num">
        <short>Here: ignored</short>
        <notes><note>purpose?</note></notes>
      </element>
      <element name="TCustomForm.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance.
          </p>
          <p>
            <var>Destroy</var> ensures that unhandled queued asynchronous calls in the <var>Application</var> instance are removed for the form.
          </p>
          <p>
            <var>Destroy</var> disables auto-sizing to prevent resize messages while the form is being freed. Destroy frees resources allocated for the form instance, including its Icon and any allocated icon handles. The form instance is removed from Screen, and its ActionLists are freed. Destroy frees all form handlers added to the class instance.
          </p>
          <p>
            Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Icon"/>
          <link id="Application"/>
          <link id="Screen"/>
          <link id="TApplication"/>
          <link id="TScreen"/>
        </seealso>
      </element>
      <element name="TCustomForm.AfterConstruction"/>
      <element name="TCustomForm.BeforeDestruction"/>
      <element name="TCustomForm.GetControlClassDefaultSize" link="#lcl.controls.TControl.GetControlClassDefaultSize"/>
      <element name="TCustomForm.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <element name="TCustomForm.BigIconHandle">
        <short>The Handle of the big form icon</short>
      </element>
      <element name="TCustomForm.BigIconHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.Close">
        <short>Closes the form</short>
        <descr>
          <p>
            Close does not necessarily destroy the form. Modal forms only are hidden. When the MainForm is closed, the application terminates.
          </p>
          <p>
            An <var>OnCloseQuery</var> handler can refuse to allow the form to close.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.CloseQuery"/>
        </seealso>
      </element>
      <element name="TCustomForm.CloseQuery">
        <short>Asks the OnCloseQuery handler whether the form can close</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnCloseQuery"/>
        </seealso>
      </element>
      <element name="TCustomForm.CloseQuery.Result">
        <short/>
      </element>
      <element name="TCustomForm.DefocusControl">
        <short>Updates ActiveControl if it is to be defocused</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DefocusControl.Control">
        <short>The control that looses the focus</short>
      </element>
      <element name="TCustomForm.DefocusControl.Removing">
        <short>True when the control is removed</short>
      </element>
      <element name="TCustomForm.DestroyWnd" link="#lcl.controls.TWinControl.DestroyWnd"/>
      <element name="TCustomForm.EnsureVisible">
        <short>
          Ensures that the form is fully visible, and optionally brings it in front of all other forms
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EnsureVisible.AMoveToTop">
        <short>Bring the form to front if True</short>
      </element>
      <element name="TCustomForm.FocusControl">
        <short>
          Gives focus to the specified control
        </short>
        <descr>
          <p>
            <var>FocusControl</var> is a procedure used to give focus to the control specified in <var>WinControl</var>. FocusControl ensures that the <var>ActiveControl</var> property is updated when needed, and may raise an exception if WinControl cannot be focused. If the form instance was not already <var>Active</var>, the <var>SetFocus</var> method is called.
          </p>
        </descr>
        <errors>
          If the control or one of its parents is not visible or disabled, an exception will be raised (in <var>SetFocus</var>).
        </errors>
        <seealso/>
      </element>
      <element name="TCustomForm.FocusControl.WinControl">
        <short>The control receiving the focus</short>
      </element>
      <element name="TCustomForm.FormIsUpdating" link="#lcl.controls.TControl.FormIsUpdating">
        <short>
          Indicates if the BeginFormUpdate method has been called without a corresponding EndFormUpdate method call
        </short>
        <descr>
          <p>
            The method is used in <var>TControl</var> descendants to determine if the parent form for the control is already rendering changes to its content.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.BeginFormUpdate"/>
          <link id="TCustomForm.EndFormUpdate"/>
        </seealso>
      </element>
      <element name="TCustomForm.FormIsUpdating.Result">
        <short>
          Returns True when the internal update counter for the form contains a positive
          non-zero value
        </short>
      </element>
      <element name="TCustomForm.GetFormImage">
        <short>Makes a Bitmap image with the Form content</short>
      </element>
      <element name="TCustomForm.GetFormImage.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetRolesForControl">
        <short>The role(s) for the control in a modal form (default or cancel button)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.GetRolesForControl.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetRolesForControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.GetRealPopupParent">
        <short>
          Gets the form that is the effective parent for the pop-up, dialog, or splash screen
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.GetRealPopupParent.Result">
        <short>
          Form instance that is the parent for the pop-up form, or Nil for a splash screen
        </short>
      </element>
      <element name="TCustomForm.Hide" link="#lcl.controls.TControl.Hide"/>
      <element name="TCustomForm.IntfDropFiles">
        <short>
          Invokes the <link id="TCustomForm.OnDropFiles">OnDropFiles</link> handler of the form. This function is called by the LCL interface.
        </short>
        <descr>
          <p>
            The drop files event will be invoked when the user drops one or more dragged files onto one of forms in the application. First this event should be fired for the target form (or main form if drop target is unknown), and then for the application instance.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.IntfDropFiles.FileNames">
        <short/>
      </element>
      <element name="TCustomForm.IntfHelp">
        <short>
          Show help for control or menu item. This function is called by the LCL interface.
        </short>
        <descr/>
        <seealso>
          <link id="#lcl.controls.TControl.ShowHelp">TControl.ShowHelp</link>
        </seealso>
       </element>
      <element name="TCustomForm.IntfHelp.AComponent">
        <short/>
      </element>
      <element name="TCustomForm.IsShortcut">
        <short>
          Asks all applicable components to interpret a keystroke as a shortcut. Returns True when the specified Key and Message are active as a shortcut.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.IsShortcut.Result">
        <short>True when the specified Key was handled as a shortcut.
        </short>
      </element>
      <element name="TCustomForm.IsShortcut.Message">
        <short/>
      </element>
      <element name="TCustomForm.MakeFullyVisible">
        <short>Extends or shrinks the form to a monitor</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TCustomForm.MakeFullyVisible.AMonitor">
        <short>The monitor to use, Nil means the design-time monitor</short>
      </element>
      <element name="TCustomForm.MakeFullyVisible.UseWorkarea">
        <short>
          If True then extend to the WorkArea for the monitor. Otherwise, clip the form to the monitor bounds.
        </short>
      </element>
      <element name="TCustomForm.AutoSizeDelayedHandle">
        <short>
          Returns True if AutoSize should be skipped or delayed because of a missing handle
        </short>
        <descr/>
        <errors></errors>
        <seealso/>
        <notes><note>propagate back into TControl?</note></notes>
      </element>
      <element name="TCustomForm.AutoSizeDelayedHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize" link="#lcl.controls.TControl.GetPreferredSize"/>
      <element name="TCustomForm.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.Raw">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.WithThemeSpace">
        <short/>
      </element>
      <element name="TCustomForm.Release">
        <short>Marks the form for destruction</short>
        <descr>
          <p>
            <var>Release</var> is a procedure used to request destruction of the current form instance.
          </p>
          <p>
            <var>Release</var> checks for a <var>TApplication</var> instance in the <var>Application</var> singleton. When it is assigned (contains a value other than <b>Nil</b>), its <var>ReleaseComponent</var> method is called to free the form instance by posting an asynchronous application message. When <var>Application</var> is not assigned, the <var>Free</var> method is called to destroy the form instance.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ReleaseComponent"/>
          <link id="TCustomForm.Destroy"/>
          <link id="Application"/>
        </seealso>
      </element>
      <element name="TCustomForm.CanFocus">
        <short>True when the form can receive focus</short>
        <descr>
          <p>
            <var>CanFocus</var> is an overridden <var>Boolean</var> function which indicates if the form instance can receive focus. The return value is <b>True</b> when the form is <var>Visible</var> and <var>Enabled</var>, or the inherited <var>CanFocus</var> method returns <b>True</b>.
          </p>
          <p>
            <var>CanFocus</var> is used in the implementation of various methods in the class, including: <var>SetWindowFocus</var>, <var>UpdateShowing</var>, <var>SetActiveControl</var>, and <var>Loaded</var>.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.CanFocus.Result">
        <short>True when the form can receive focus in the application</short>
      </element>
      <element name="TCustomForm.SetFocus" link="#lcl.controls.TWinControl.SetFocus"/>
      <element name="TCustomForm.SetFocusedControl">
        <short>Handles focus switch to a control (enter/exit messages)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SetFocusedControl.Result">
        <short>False when the focused control cannot be changed</short>
      </element>
      <element name="TCustomForm.SetFocusedControl.Control">
        <short>The control that received the focus</short>
      </element>
      <element name="TCustomForm.SetRestoredBounds">
        <short>Sets the bounds for the restored control</short>
        <descr>Temporarily goes into the normal (restored) window state, if required.</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ALeft">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ATop">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.AWidth">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.AHeight">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ADefaultPosition">
        <short/>
      </element>
      <element name="TCustomForm.Show" link="#lcl.controls.TControl.Show"/>
      <element name="TCustomForm.ShowModal">
        <short>Displays the form as a modal Dialog</short>
        <descr>
          <p>
            Shows the form in a modal state and waits until it is closed by the user or by the program. Modal state means that neither the user nor the program can switch to another form already made visible before calling <var>ShowModal</var>.
          </p>
          <p>
            The form must have <var>Visible</var> set to <b>False</b> when calling <var>ShowModal</var>. The call does <b>not</b> return until the form is closed. The application switches to modal state until <var>ShowModal</var> has completed.
          </p>
          <p>
            <var>ShowModal</var> creates its own event loop using <var>ProcessMessages</var>.
          </p>
        </descr>
        <errors>
          <p>
            Raises an <var>EInvalidOperation</var> exception if the form cannot be displayed as a modal form.
          </p>
        </errors>
        <seealso/>
      </element>
      <element name="TCustomForm.ShowModal.Result">
        <short>The modal result for the dialog</short>
      </element>
      <element name="TCustomForm.ShowOnTop">
        <short>Shows this form in front of all other forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SmallIconHandle">
        <short>
          Returns (and eventually creates) the Handle of the small Form or Application Icon.
        </short>
        <seealso>
          <link id="TCustomForm.Icon"/>
        </seealso>
      </element>
      <element name="TCustomForm.SmallIconHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetChildren">
        <short>Invokes Proc for all Controls and also for all Components with no Parent</short>
        <descr/>
        <seealso>
          <link id="#lcl.controls.TWinControl.GetChildren">TWinControl.GetChildren</link>
        </seealso>
      </element>
      <element name="TCustomForm.GetChildren.Proc">
        <short>The callback method</short>
      </element>
      <element name="TCustomForm.GetChildren.Root">
        <short>Components are enumerated only if Root is Self</short>
      </element>
      <element name="TCustomForm.WantChildKey">
        <short/>
        <descr>Always returns False in TCustomForm</descr>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.WantChildKey.Result">
        <short>Here: always False</short>
      </element>
      <element name="TCustomForm.WantChildKey.Child">
        <short>Control with the key message for the method</short>
      </element>
      <element name="TCustomForm.WantChildKey.Message">
        <short>Key message from the child control</short>
      </element>
      <element name="TCustomForm.RemoveAllHandlersOfObject" link="#lcl.lclclasses.TLCLComponent.RemoveAllHandlersOfObject"/>
      <element name="TCustomForm.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow">
        <short>Adds a handler for the first Show of the form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow.OnFirstShowHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerFirstShow">
        <short>Removes a handler for the first Show of the form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerFirstShow.OnFirstShowHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerClose">
        <short>Adds a handler for form Close</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerClose.OnCloseHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerClose.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerClose">
        <short>Removes a handler for form Close</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerClose.OnCloseHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerCreate">
        <short>Adds a handler for form Create</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerCreate.OnCreateHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerCreate.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerCreate">
        <short>Removes a handler for form Create</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerCreate.OnCreateHandler">
        <short/>
      </element>
      <element name="TCustomForm.ActiveMDIChild">
        <short>Returns the currently active MDI child form</short>
        <descr>
          A non-<b>nil</b> result is returned only when FormStyle contains <var>fsMDIForm</var> or <var>fsMDIChild</var>; otherwise Result is <b>nil</b>.
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveMDIChild.Result">
        <short>Nil if the form is neither an MDI host nor child</short>
      </element>
      <element name="TCustomForm.GetMDIChildren" link="#lcl.forms.TCustomForm.MDIChildren"/>
      <element name="TCustomForm.GetMDIChildren.Result">
        <short>Nil if caller isn't an MDI type or handle isn't allocated</short>
      </element>
      <element name="TCustomForm.GetMDIChildren.AIndex">
        <short/>
      </element>
      <element name="TCustomForm.MDIChildCount" link="#lcl.forms.TCustomForm.MDIChildren"/>
      <element name="TCustomForm.MDIChildCount.Result">
        <short>-1 if caller isn't an MDI form or handle is not allocated</short>
      </element>
      <element name="TCustomForm.AutoScale">
        <short>Sets scaled to True and AutoAdjustLayout to current monitor PPI</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.Dock" link="#lcl.controls.TControl.Dock"/>
      <element name="TCustomForm.Dock.NewDockSite">
        <short/>
      </element>
      <element name="TCustomForm.Dock.ARect">
        <short/>
      </element>
      <element name="TCustomForm.UpdateDockCaption" link="#lcl.controls.TWinControl.UpdateDockCaption"/>
      <element name="TCustomForm.UpdateDockCaption.Exclude">
        <short/>
      </element>
      <element name="TCustomForm.Active">
        <short>Contains True when the form has the focus</short>
        <descr>Use active to check if the form has the focus</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveControl">
        <short>Specifies the active control on the form</short>
        <descr>Use this to get or set the active control on this form.</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveDefaultControl">
        <short>Specifies the Default control for the Form</short>
        <descr>The Default control reacts on the Enter key pressed.
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.AllowDropFiles">
        <short>Specifies whether files can be dropped onto this form</short>
        <descr>
          <p>
            AllowDropFiles is a Boolean property which indicates whether this form receives an OnDropFiles event when files are dropped on form during a drag-and-drop operation.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TCustomForm.AlphaBlend">
        <short>Allows the form to be drawn with translucency</short>
        <descr>
          <p>
            <var>AlphaBlend</var> is a <var>Boolean</var> property which indicates if the form can be drawn with translucency. When set to <b>True</b>, the form is drawn with a degree of transparency and diffusion. This allows other forms (and their controls) which have a lower Z-Order value to be seen beneath the form. The default value for the property is <b>False</b>.
          </p>
          <p>
            Use <var>AlphaBlendValue</var> to specify the degree of transparency and diffusion applied to the form content.
          </p>
          <p>
            Changing the value in AlphaBlend causes the widgetset class to be notified of the property change at run-time when a handle has been allocated for the form instance.  A change to the property value is not rendered at design-time.
          </p>
          <p>
            AlphaBlend and AlphaBlendValue are used in the implementation of the <var>InitializeWnd</var> method, and passed as arguments to methods in the widgetset class when either of the values are changed.
          </p>
          <remark>
            Please note: AlphaBlend requires support from both the Desktop Environment (DE) and the hardware for the system; it may not work on all hardware, or platform / operating system combinations supported as Lazarus targets.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomForm.AlphaBlendValue"/>
          <link id="TCustomForm.InitializeWnd"/>
        </seealso>
      </element>
      <element name="TCustomForm.AlphaBlendValue">
        <short>The translucence level for the form (0=transparent, 255=opaque)</short>
        <descr>
          <p>
            <var>AlphaBlendValue</var> is a <var>Byte</var> property which indicates the level of translucency for the form when <var>AlphaBlend</var> is set to <b>True</b>. AlphaBlendValue must be in the range 0..255 (for the Byte data type), where 0 represents 100% transparency and 255 is for full opacity.
          </p>
          <p>
            Changing the value for the property causes the widgetset class to be notified of the change in the property value at run-time when a handle has been allocated for the form.
          </p>
          <p>
            Set AlphaBlend to <b>True</b> to enable translucency for the form.
          </p>
          <p>
            AlphaBlend and AlphaBlendValue are used in the implementation of the <var>InitializeWnd</var> method, and passed as arguments to methods in the widgetset class when either of the values are changed.
          </p>
          <remark>
            Please note: AlphaBlend and AlphaBlendValue require support from both the Desktop Environment (DE) and the hardware for the system; it may not work on all hardware, or platform / operating system combinations supported as Lazarus targets.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomForm.AlphaBlend"/>
          <link id="TCustomForm.InitializeWnd"/>
        </seealso>
      </element>
      <element name="TCustomForm.AutoScroll">
        <short>Indicates if the form can automatically show or hide scroll bars</short>
        <descr>
          <p>
            <var>AutoScroll</var> is a <var>Boolean</var> property which indicates if the form can automatically show or hide its scroll bars. Set <var>AutoScroll</var> to <b>True</b> to enable scroll bars when the form size is too small to display its content in its entirety. AutoScroll can only be <b>True</b> when the <var>BorderStyle</var> for the form is <var>bsSizeable</var> or <var>bsSizeToolWin</var>, and may be changed to <b>False</b> at run-time when setting the value in the BorderStyle property to another value.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.BorderStyle"/>
        </seealso>
      </element>
      <element name="TCustomForm.BorderIcons">
        <short>Specifies the icons which appear in the title bar for the form</short>
        <descr>
          <p>
            <var>BorderIcons</var> is a <var>TBorderIcons</var> property which contains valued from the <var>TBorderIcon</var> enumeration, and indicates the icons displayed in the title bar for the form instance. The default value for the property includes the following enumeration values:
          </p>
          <ul>
            <li>biSystemMenu</li>
            <li>biMinimize</li>
            <li>biMaximize</li>
          </ul>
          <p>
            See <link id="TBorderIcon">TBorderIcon</link> for more information about the enumeration values and their usage.
          </p>
          <p>
            Changing the value in BorderIcons causes the <var>WidgetSetClass</var> for the form instance to be notified of the new values in the property.
          </p>
          <p>
            Values in BorderIcons may be automatically changed at run-time when a new value is assigned to the <var>BorderStyle</var> property; see <link id="DefaultBorderIcons">DefaultBorderIcons</link> for the icons used for a specific border style.
          </p>
        </descr>
        <seealso>
          <link id="TBorderIcons"/>
          <link id="TBorderIcon"/>
          <link id="TCustomForm.BorderStyle"/>
          <link id="DefaultBorderIcons"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.BorderStyle">
        <short>
          The border style affects the title bar, border and resize behavior of the form.
        </short>
        <descr>
          <p>
            Use borderstyle to get or set the appearance of the form's border.
          </p>
          <p>
            By default it is a sizeable window, but it could, for example, be a dialog form
            or a tool window, or could be non-sizeable.
          </p>
          <p>
            This property is slightly different (has a different base type) from the
            <var>TCustomControl.BorderStyle</var> property. When the form is put into
            another control the window borders depend on the widget set. There are no
            borders under GTK.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.AutoScroll"/>
          <link id="#lcl.controls.TFormBorderStyle">TFormBorderStyle</link>
          <link id="#lcl.controls.TBorderStyle">TBorderStyle</link>
          <link id="#lcl.controls.TCustomControl.BorderStyle">TCustomControl.BorderStyle</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.CancelControl">
        <short>The control associated with the Cancel action</short>
        <descr>
          <p>
            Determines the control associated with the Cancel action (which exits from the modal form without changing anything). This is usually a button with the caption 'Cancel', but might be an 'Exit' button or anything else the application programmer decides. This control is selected either by explicitly clicking with the mouse, or by hitting the 'Esc' key.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.DefaultControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Caption" link="#lcl.controls.TControl.Caption">
        <short>The text displayed in the title bar for the form</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Color" link="#lcl.controls.TControl.Color">
        <short>The background color for the form</short>
        <descr>The form's background color.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.DefaultControl">
        <short>The control associated with the default action for this form</short>
        <descr>
          <p>
            This is typically a button such as 'Accept' which is highlighted in some way on-screen to indicate that this is the default action, and is selected either by hitting 'Return' or 'Enter' or by selecting that control with the mouse.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.DefaultMonitor">
        <short>The monitor on which the form is displayed</short>
        <descr>
          <p>Possible values:</p>
          <dl>
            <dt>dmDesktop</dt>
            <dd>No attempt to choose specific monitor.</dd>
            <dt>dmPrimary</dt>
            <dd>On the primary monitor.</dd>
            <dt>dmMainForm </dt>
            <dd>
              On the same monitor as the main form. If there is no main form then use dmPrimary behavior.
            </dd>
            <dt>dmActiveForm</dt>
            <dd>
              On the same monitor as the currently active form. If there is no active form use dmMainForm behavior.
              </dd>
          </dl>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Designer">
        <short>The designer object when the form is in design state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EffectiveShowInTaskBar">
        <short>
          Value from ShowInTaskBar adjusted for the default taskbar behavior in the application
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.FormState">
        <short>State flags for the form</short>
        <descr>
          <p>
            <var>FormState</var> is a read-only <var>TFormState</var> property which contains state flags enacted for the form instance. Values from the TFormStateType enumeration are included in, or excluded from, the set type when corresponding actions occur (or are resolved) for the form instance.
          </p>
          <p>
            See <var>TFormStateType</var> for more information on the values and meanings in the enumeration.
          </p>
          <p>
            FormState is updated when properties for the form instance are changed, and in methods which respond to window and control messages in the form instance.
          </p>
        </descr>
        <seealso>
          <link id="TFormState"/>
          <link id="TFormStateType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.FormStyle">
        <short>Indicates the style for the form</short>
        <descr>
          <p> Possible values:</p>
          <dl>
            <dt>fsNormal </dt>
            <dd>Usual style.</dd>
            <dt>fsStayOnTop</dt>
            <dd>Form is positioned above all application's forms, except those which have
              fsStayOnTop style.</dd>
            <dt>fsSystemStayOnTop</dt>
            <dd>Form is positioned above all OS windows, except other OS top-level windows.</dd>
            <dt>fsSplash</dt>
            <dd>Form is border-less.</dd>
            <dt>fsMDIForm</dt>
            <dd>MDI parent form.</dd>
            <dt>fsMDIChild</dt>
            <dd>MDI child form.</dd>
          </dl>
        </descr>
        <seealso>
          <link id="#lcl.controls.TFormStyle">TFormStyle</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.HelpFile">
        <short>The name of the help file for the form</short>
        <descr>
          <p>
            <var>HelpFile</var> is a <var>String</var> property which contains the name of the help file for the form instance. HelpFile can use a fully-qualified path to the help file if it is not locate in the same directory as the application which implements the form.
          </p>
          <p>
            The value in HelpFile is used in <var>TApplication</var> when it retrieves the help file name from the active form in the application.
          </p>
        </descr>
        <seealso>
          <link id="TApplication"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Icon">
        <short>The Icon associated with this Form (in minimized state)</short>
        <descr>
          <p>
            <var>Icon</var> is a <var>TIcon</var> property which contains the graphical icon for the form instance. Icon contains the image displayed on the task bar area when a form is minimized. If an Icon is not explicitly assigned for the form, the icon for the <var>Application</var> is used.
          </p>
          <p>
            Assigning a new value to Icon causes existing icon handles to be freed, and the widgetset class is notified to re-create the icon handles.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.BigIconHandle"/>
          <link id="TCustomForm.SmallIconHandle"/>
          <link id="#lcl.graphics.TIcon">TIcon</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.KeyPreview">
        <short>Allows the form to intercept keystrokes in child controls</short>
        <descr>
          <p>
            <var>KeyPreview</var> is a <var>Boolean</var> property which controls whether the form can intercept key strokes from child controls. When KeyPreview is set to True, the form is allowed to receive KeyDown, KeyUp, and KeyPress events before they are received/applied to the ActiveControl in the form.
          </p>
          <p>
            The default value for the property is False.
          </p>
          <p>
            KeyPreview is used in the implementation of key handling methods in TWinControl. KeyPreview is often enabled for modal dialogs to allow the parent form to handle specific user interactions.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.MDIChildren">
        <short>Provides indexed access to MDI child forms, when this is a MDI form</short>
        <descr>
          <p>
            <var>MDIChildren</var> is a read-only indexed <var>TCustomForm</var> property which provides access to the child forms in a Multi-Document Interface (MDI) application. In an MDI application, one of the forms acts as the main form for the application, and is the container for its MDI child forms. In addition, an MDI child form can be nested in another MDI child form.
          </p>
          <remark>
            Please note: Historically, support for MDI is dependent on the underlying widgetset or platform. Some widgetsets provide better support for MDI than others. The consensus is that the QT/QT5  widgetsets offers the best level of support for MDI applications.
          </remark>
          <p>
            The form role is determined by the value in the FormStyle property. fsMDIForm is used for the main form, and fsMDIChild for the child forms. MDIChildren is relevant when the current form instance uses one of those MDI from style values.
          </p>
          <p>
            The <var>Integer</var> <var>Index</var> value is used to access the MDI child forms for the current form instance by the ordinal for the requested form. The return value contains the TCustomForm instance at the specified position, as determined using the GetMDIChildren method in the widgetset class. The return value can be <b>Nil</b> when the current form does not use a FormStyle with the value fsMDIForm or fsMDIChild, or when a handle has not yet been allocated for the form instance. The return value is always Nil at design-time.
          </p>
          <p>
            Use <var>MDIChildCount</var> to get the number MDI child forms for the form instance.
          </p>
          <p>
            Use <var>ActiveMDIChild</var> to get the active MDI child form in the application.
          </p>
          <p>
            Set the value in the <var>FormStyle</var> property to indicate that the class is used as a MDI form.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.FormStyle"/>
          <link id="TCustomForm.MDIChildCount"/>
          <link id="TCustomForm.ActiveMDIChild"/>
        </seealso>
      </element>
      <element name="TCustomForm.MDIChildren.I">
        <short>Ordinal position for the MDI Child form requested</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Menu">
        <short>The main menu for the form instance</short>
        <descr>
          <p>
            <var>Menu</var> is the <var>TMainMenu</var> instance assigned to the form.
          </p>
          <p>
            Assigning a new value to Menu causes other forms on the <var>Screen</var> to be checked for a duplicate menu assignment. A singlular TMainMenu instance cannot be assigned to more than one form. An <var>EInvalidOperation</var> is raised if another form alreasy uses the menu instance. The <var>UpdateMenu</var> method is called when the new property value has been set.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.menus.TMainMenu">TMainMenu</link>
          <link id="Screen"/>
          <link id="TScreen.Forms"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.ModalResult">
        <short>Specifies the return value for a form (or dialog) displayed modally</short>
        <descr>
          <p>
            <var>ModalResult</var> is a <var>TModalResult</var> property which contains the value derived when the form is displayed modally. Setting a new value for the property causes the widgetset class to be notified when a handle has been allocated for the form.
          </p>
          <p>
            The value in ModalResult is updated when the <var>ShowModal</var> method is called for the form instance. It may is updated in the <var>CloseModal</var> method when <var>CloseQuery</var> is <b>False</b> and <var>CloseAction</var> is <var>caNone</var>. Finally, it is set to <var>mrCancel</var> in the <var>Close</var> method when <var>FormState</var> contains the value <var>fsModal</var>.
          </p>
          <p>
            See <link id="TModalResult">TModalResult</link> for more information about the enumertation values and their meanings.
          </p>
        </descr>
        <seealso>
          <link id="TModalResult"/>
          <link id="TCustomForm.ShowModal"/>
          <link id="TCustomForm.Close"/>
          <link id="TCustomForm.FormState"/>
          <link id="TCustomForm.CloseQuery"/>
        </seealso>
      </element>
      <element name="TCustomForm.Monitor">
        <short>The Monitor where the form is shown</short>
        <descr>
          <p>
            <var>Monitor</var> is a read-only <var>TMonitor</var> property which contains the monitor where the form was displayed. Monitor defaults to the <var>TMonitor</var> instance for the Parent form when it has been assigned.
          </p>
          <p>
            When the parent form has not been assigned, and a handle exists for the form instance, the widgetset class is notified of the current coordinates for the form. The <var>MonitorFromWindow</var> method in the <var>Screen</var> singleton is called to locate the window closest to the the form (using its handle).
          </p>
          <p>
            When neither a parent form nor a window handle are available, the <var>MonitorFromPoint</var> method in the <var>Screen</var> singleton is used to locate the form located at the <var>Top</var> and <var>Left</var> coordinates for the form instance.
          </p>
        </descr>
        <seealso>
          <link id="Screen"/>
          <link id="TScreen"/>
          <link id="TMonitor"/>
          <link id="GetParentForm"/>
        </seealso>
      </element>
      <element name="TCustomForm.LastActiveControl">
        <short>
          Tracks changes in the focus for the active form or the last active control for the current form
        </short>
        <descr>
          <p>
            <var>LastActiveControl</var> is a read-only <var>TWinControl</var> property used to track a change in the focus for the active form or the control on the current form instance. It is updated when changes are made to the <var>ActiveControl</var> property, or in the <var>SetFocusedControl</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.ActiveControl"/>
          <link id="TCustomForm.SetFocusedControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.PopupMode">
        <short>Defines where popup menus are shown</short>
        <descr>
          <p>
            <var>PopupMode</var> is a <var>TPopupMode</var> property which controls the display policy for pop-up forms. The default value for the property is <var>pmNone</var>. See <var>TPopupMode</var> for more information about the values and meanings in the enumeration.
          </p>
          <p>
            Changing the value in PopupMode causes the value in <var>PopupParent</var> to be changed when the property is set to pmAuto or pmNone. At run-time, the widgetset class is notified of the change to the PopupParent property.
          </p>
          <p>
            PopupMode is used in the implementation of the <var>GetRealPopupParent</var> and <var>ShowModal</var> methods.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.PopupParent"/>
          <link id="TCustomForm.GetRealPopupParent"/>
          <link id="TCustomForm.ShowModal"/>
          <link id="TPopupMode"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.PopupParent">
        <short>
          Parent form which owns the current form instance when displayed as a pop-up window
        </short>
        <descr>
          <p>
            <var>PopupParent</var> is a <var>TCustomForm</var> property which contains the parent form which owns the current form instance when displayed as a pop-up window.
          </p>
          <p>
            Setting a new value for the property causes the existing pop-up parent form to be removed from the free notifications for the application. A new non-Nil pop-up parent is added to the free notification list, and its <var>PopupMode</var> property is set to <var>pmExplicit</var>.
          </p>
          <p>
            At run-time, the widget set class is notified of the change in the <var>PopupParent</var> property. The notification is not performed at design-time.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.PopupMode"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnActivate">
        <short>Handler called when the form receives focus</short>
        <descr>
          <p>
            This handler is called when the form receives focus for the first time at application start up, and then subsequently each time focus is changed from another window for the same application to this window.
          </p>
          <p>
            For focus changes between different applications, the <var>Application.OnActivate</var> event handler is called instead.
          </p>
        </descr>
        <seealso>
          <link id="#LCL.Forms.TApplication.OnActivate">TApplication.OnActivate</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnClose">
        <short>
          Handler called when the form is closed. It determines what happens to the form (destroy, hide...).
        </short>
        <descr>
          <p>
            <var>OnClose</var> is a <var>TCloseEvent</var> property which represents the event handler signalled when a form calls its <var>Close</var> or <var>CloseModal</var> method.
          </p>
          <p>
            OnClose is triggered from the <var>DoClose</var> method immediately before calling any internal form handlers registered for the <var>fhtClose</var> form handler action type. OnClose can be used to detemine the action performed in subsequent form handlers by setting the value in the <var>CloseAction</var> argument.
          </p>
          <p>
            An application must implement and assign an object procedure using the signature for TCloseEvent to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Close"/>
          <link id="TCustomForm.DoClose"/>
          <link id="TCloseEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnCloseQuery">
        <short>
          Event handler signalled when trying to close a form
        </short>
        <descr>
          <p>
            <var>OnCloseQuery</var> is a <var>TCloseQueryEvent</var> property which contains the event handler signalled to determine whether the form can be closed. Set the value in the <var>CanClose</var> argument to <b>True</b> to allow the form instance to be closed. The default value for CanClose is <b>True</b>.
          </p>
          <p>
            Use OnCloseQuery to perform any actions or dialogs needed to confirm that the form can in fact be closed.
          </p>
          <p>
            An application must implement and assign an object procedure using the signature in TCloseQueryEvent to respond to the event notification.
          </p>
          <p>
            OnCloseQuery is signalled from the <var>CloseQuery</var> method, and occurs immediately after MDI child forms have called their CloseQuery methods.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.CloseQuery"/>
          <link id="TCustomForm.MDIChildren"/>
          <link id="TCloseQueryEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnCreate">
        <short>Handler called when the form has been created</short>
        <descr>
          <p>
            <var>OnCreate</var> is a <var>TNotifyEvent</var> property which implements an event handler signalled when a new form instance is created. OnCreate can be used to perform any action needed to configure the new form instance, or update the application where the form is used.
          </p>
          <p>
            OnCreate is triggered from the <var>DoCreate</var> method (when assigned) before signalling any form handlers using the <var>fhtCreate</var> form handler action type. At this point, the initial coordinates for the form have been assigned, but are not realized until until DoCreate has been completed.
          </p>
          <p>
            An application must implement and assign an object procedure using the signature for the handler to allow responding to the notification.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.DoCreate"/>
          <link id="TFormHandlerType"/>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDeactivate">
        <short>Handler called when the form is deactivated (loses focus)</short>
        <descr>
          OnDeactivate is a TNotifyEvent property which contains an event handler signalled when form is deactivated (loses focus). OnDeactivate is signalled from the Deactivate method (when assigned).
        </descr>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDestroy">
        <short>Handler called when the form is destroyed</short>
        <descr>
          <p>
            OnDestroy is a TNotifyEvent property signalled when the form instance is destroyed. OnDestroy is signalled from the DoDestroy method (when assigned) as one of the steps before destruction of the class instance. Before the event handler is triggered, the form has been hidden and the Menu from the main form in the Application has been unmerged.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDropFiles">
        <short>Handler called when files have been dropped</short>
        <descr>
          <p>
            <var>OnDropFiles</var> is a <var>TDropFilesEvent</var> event handler signalled when a File Drag notification is received from the LCL / widgetset interface.
          </p>
          <p>
            The <var>Sender</var> argument contains the current form instance. The <var>FileName</var> argument contains an array with the file names for the drop operation.
          </p>
          <p>
            Set <var>AllowDropFiles</var> to <b>True</b> to enable drog and drop operations, and execution of this event handler.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.AllowDropFiles"/>
          <link id="TDropFilesEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnHelp">
        <short>Handler called when Help is requested</short>
        <descr>
          <p>
            <var>OnHelp</var> is a <var>THelpEvent</var> property which contains the event handler signalled when a Help command is executed for the form instance. Arguments to the event handler identify the command and the context used in the help request.
          </p>
          <p>
            <var>Command</var> contains the help request type, and corresponds to the values used in the Windows WinHelp API.
          </p>
          <p>
            <var>Data</var> is a <var>PtrInt</var> type which points the context information for the help request.
          </p>
          <p>
            The <var>CallHelp</var> argument indicates if handler(s) in the <var>Application</var> instance should be called when the event handler in the form is completed. Set CallHelp to <b>False</b> when the help request has been satified in the event handler.
          </p>
          <p>
            An application must implement and assign an object function using the signature for the handler to respond to the event notification.
          </p>
          <p>
            Set the return value to <b>True</b> if the Help request was successfully executed.
          </p>
          <p>
            The OnHelp event handler for the active form is signalled when the <var>TApplication</var> instance executes its <var>DoOnHelp</var> method. The arguments to the event handler contain the values intercepted in the WMHelp message processing for the application. If the OnHelp event handler has not been assigned for the active form, the OnHelp event handler in the Application singleton is signalled (when assigned).
          </p>
        </descr>
        <seealso>
          <link id="THelpEvent"/>
          <link id="Application"/>
          <link id="TApplication.OnHelp"/>
          <link id="TApplication.DoOnHelp"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnHide">
        <short>Handler called when the form is being hidden</short>
        <descr>
          <p>
            <var>OnHide</var> is a <var>TNotifyEvent</var> property that represents the event handler signalled when the form instance is hidden. OnHide is triggered (when assigned) in the <var>DoHide</var> method, and occurs when the <var>CMShowingChanged</var> control message is applied to the <var>Showing</var> property for the form instance.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.DoHide"/>
          <link id="TCustomForm.Hide"/>
          <link id="TCustomForm.Visible"/>
          <link id="TCustomForm.CMShowingChanged"/>
          <link id="#lcl.controls.TWinControl.Showing">TWinControl.Showing</link>
          <link id="#rtl.classes.TNotifyEvent">TNotifyEvent</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnResize" link="#lcl.controls.TControl.OnResize"/>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnShortcut">
        <short>
          Handler called when a key is pressed, before further handling of the key
        </short>
        <descr>
          <p>
            OnShortcut is a TShortcutEvent property that represents the event handler signalled (when assigned) to detect and handle a shortcut key for the form instance. OnShortcut is called from the IsShortcut method used to examine keystroke events intercepted and forwarded by the Application.
          </p>
          <p>
            The Msg argument contains the key event examined in the handler. Handled indicates that the key is handled by the event when set to True.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.IsShortCut"/>
          <link id="TApplication.IsShortCut"/>
          <link id="TApplication.OnShortCut"/>
          <link id="TShortCutEvent"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnShow">
        <short>Handler called when the form becomes visible</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.OnShowModalFinished">
        <short>Event handler signalled when modal display of the form has been completed</short>
        <descr>
          <p>
            <var>OnShowModalFinished</var> is a <var>TModalDialogFinished</var> property that implements the event handler signalled when modal display of the form has been completed. An application must implement an object procedure using the signature in <var>TModalDialogFinished</var>, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ModalFinished"/>
          <link id="TApplication.OnModalEnd"/>
        </seealso>
        <notes>
          <note>
            Is this a remnant? Not used in ShowModal or CloseModal. It does not appear to be used anywhere in the current LCL version.
          </note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnWindowStateChange">
        <short>Handler called when the form is minimized, maximized or restored</short>
        <descr>
          <p>
            <var>OnWindowStateChange</var> is a <var>TNotifyEvent</var> property which represents the event handler signalled when the value for the <var>WindowState</var> property is changed. OnWindowStateChange is triggered (when assigned) from the <var>Resizing</var> method, and occurs when the <b>WM_SIZE</b> window message for the action is handled.
          </p>
          <p>
            See TWindowState for details about the values and meanings in the enumeration.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WIndowState"/>
          <link id="TCustomForm.Resizing"/>
          <link id="TCustomForm.WMSize"/>
          <link id="TWindowState"/>
        </seealso>
      </element>
      <element name="TCustomForm.ParentFont" link="#lcl.controls.TControl.ParentFont"/>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Position">
        <short>The initial placement for the form</short>
        <descr>
          <p>
            <var>Position</var> is a <var>TPosition</var> property which indicates the size and position policy used to display the form instance. The default value for the property is poDesigned, and indicates that the coordinates used in the form designer are used at run-time. See <link id="TPosition">TPosition</link> for the other values, and their meanings, available for the property.
          </p>
          <p>
            Changing the value in Position causes the value in <var>AutoSize</var> to be updated when needed, and calls <var>UpdateControlState</var>. No additional actions are performed at design-time.
          </p>
          <p>
            <var>MoveToDefaultPosition</var> is called when a handle exists for the form instance and it has not been displayed yet.
          </p>
        </descr>
        <seealso>
          <link id="TForm.AutoSize"/>
          <link id="TCustomForm.MoveToDefaultPosition"/>
          <link id="TPosition"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredLeft">
        <short>
          The Left coordinate for the form when it is restored (i.e. changes from minimized or maximized)
        </short>
        <descr>
          <p>
            <var>RestoredLeft</var> is a read-only <var>Integer</var> property which contains the left coordinate for the form when its size is altered in <var>WMSize</var> or <var>WMMove</var> message handlers. The property value is applied when the aynchronous queued event handler for the form is executed, and calls the <var>DoOnChangeBounds</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="#lcl.controls.TControl.DoOnChangeBounds">TControl.DoOnChangeBounds</link>
          <link id="#lcl.controls.TControl.Left">TControl.Left</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredTop">
        <short>
          The Top coordinate for the form when it is restored (i.e. changes from minimized or maximized)
        </short>
        <descr>
          <p>
            <var>RestoredTop</var> is a read-only <var>Integer</var> property which contains the top  coordinate for the form when its size is altered in <var>WMSize</var> or <var>WMMove</var> message handlers. The property value is applied when the aynchronous queued event handler for the form is executed, and calls the <var>DoOnChangeBounds</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="#lcl.controls.TControl.DoOnChangeBounds">TControl.DoOnChangeBounds</link>
          <link id="#lcl.controls.TControl.Left">TControl.Left</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredWidth">
        <short>The width of the form when it is resized</short>
        <descr>
          <p>
            <var>RestoredWidth</var> is a read-only <var>Integer</var> property which contains the Width for the form when its size is altered in <var>WMSize</var> or <var>WMMove</var> message handlers. The property value is applied when the aynchronous queued event handler for the form is executed, and calls the <var>DoOnChangeBounds</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="#lcl.controls.TControl.DoOnChangeBounds">TControl.DoOnChangeBounds</link>
          <link id="#lcl.controls.TControl.Width">TControl.Width</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredHeight">
        <short>The height of the form when it is resized</short>
        <descr>
          <p>
            <var>RestoredHeight</var> is a read-only <var>Integer</var> property which contains the height for the form when size is altered in <var>WMSize</var> or <var>WMMove</var> message handlers. The property value is applied when the aynchronous queued event handler for the form is executed, and calls the <var>DoOnChangeBounds</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="#lcl.controls.TControl.Height">TControl.Height</link>
          <link id="#lcl.controls.TControl.DoOnChangeBounds">TControl.DoOnChangeBounds</link>
        </seealso>
      </element>

      <element name="TCustomForm.ShowInTaskBar">
        <short>How the form is represented in the system Task Bar</short>
        <descr>
          <p>
            <var>ShowInTaskBar</var> is a <var>TShowInTaskbar</var> property which indicates how the form is represented on the system task bar. The default value for the property is <var>stDefault</var>, and indicates the default behavior for the widgetset, platform, or operating system is used. See <link id="TShowInTaskbar">TShowInTaskbar</link> for more information about values in the enumeration and their meanings.
          </p>
          <p>
            ShowInTaskBar is used in conjunction with the <var>TaskBarBehavior</var> property in the <var>Application</var> singleton to determine the effective visibility for the form on the system task bar. For example: The task bar behavior may require grouping related forms under a single form icon.
          </p>
          <p>
            Changing the value for the property causes the effective visibility to be recalculated when the form is not hidden, or a MDI child form. The new effective task bar visibility is posted to the widgetset class.
          </p>
        </descr>
        <seealso>
          <link id="TShowInTaskbar"/>
          <link id="Application"/>
          <link id="TApplication.TaskBarBehavior"/>
        </seealso>
      </element>

      <element name="TCustomForm.Visible" link="#lcl.controls.TControl.Visible"/>

      <element name="TCustomForm.WindowState">
        <short>
          Indicates whether the form is displayed in a minimized, maximized, fullscreen or normal state
        </short>
        <descr>
          <p>
            <var>WindowState</var> is a <var>TWindowState</var> property which indicates whether the form is currently displayed minimized, maximized, fullscreen or normal (restored) state. The default value is <var>wsNormal</var> (i. e. neither minimized nor maximized).
          </p>
          <p>
            Changing the value for the property at run-time causes the <var>ShowWindow</var> routine to be called with the Integer display command representing the new property value. The action is not performed at design-time, or when <var>Showing</var> is set to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Show"/>
          <link id="TWindowState"/>
          <link id="#lcl.controls.TWinControl.Showing">TWinControl.Showing</link>
          <link id="#lcl.lclintf.ShowWindow">ShowWindow</link>
        </seealso>
      </element>

      <element name="TCustomFormClass">
        <short>Class reference for the TCustomForm class</short>
        <descr>
          <p>
            Used primarily in the implementation of window classes for the Lazarus IDE.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm"/>
        </seealso>
      </element>

      <element name="TForm" link="#lcl.forms.TCustomForm"/>

      <element name="TForm.FLCLVersion" link="#lcl.forms.TForm.LCLVersion"/>

      <element name="TForm.LCLVersionIsStored" link="#lcl.forms.TForm.LCLVersion"/>
      <element name="TForm.LCLVersionIsStored.Result" link="#lcl.forms.TForm.LCLVersion.Result"/>

      <element name="TForm.WSRegisterClass">
        <short/>
        <descr>
          WSRegisterClass is an overridden class procedure used to register the widget set class used to create new instances of the form.
        </descr>
        <seealso/>
      </element>

      <!-- procedure Visibility: protected -->
      <element name="TForm.CreateWnd" link="#lcl.controls.TWinControl.CreateWnd"/>
      <element name="TForm.Loaded" link="#lcl.forms.TCustomForm.Loaded"/>
      <element name="TForm.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TForm.Create.TheOwner">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Cascade">
        <short>Arranges MDI child forms so they overlap</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Next">
        <short>Activates the next child MDI form (fsMDIChild) in the form sequence</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Previous">
        <short>Activates the previous MDI child form in the form sequence</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Tile">
        <short>Arranges MDI child forms side by side</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TForm.ClientHandle" link="#lcl.forms.TCustomForm.ClientHandle"/>
      <element name="TForm.DockManager" link="#lcl.controls.TWinControl.DockManager"/>
      <element name="TForm.Action" link="#lcl.controls.TControl.Action"/>
      <element name="TForm.ActiveControl" link="#lcl.forms.TCustomForm.ActiveControl"/>
      <element name="TForm.Align" link="#lcl.controls.TControl.Align"/>
      <element name="TForm.AllowDropFiles" link="#lcl.forms.TCustomForm.AllowDropFiles"/>
      <element name="TForm.AlphaBlend" link="#lcl.forms.TCustomForm.AlphaBlend"/>
      <element name="TForm.AlphaBlendValue" link="#lcl.forms.TCustomForm.AlphaBlendValue"/>
      <element name="TForm.Anchors" link="#lcl.controls.TControl.Anchors"/>
      <element name="TForm.AutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <element name="TForm.AutoSize" link="#lcl.controls.TControl.AutoSize"/>
      <element name="TForm.BiDiMode" link="#lcl.controls.TControl.BiDiMode"/>
      <element name="TForm.BorderIcons" link="#lcl.forms.TCustomForm.BorderIcons"/>
      <element name="TForm.BorderStyle" link="#lcl.forms.TCustomForm.BorderStyle"/>
      <element name="TForm.BorderWidth" link="#lcl.controls.TWinControl.BorderWidth"/>
      <element name="TForm.Caption" link="#lcl.controls.TControl.Caption"/>
      <element name="TForm.ChildSizing" link="#lcl.controls.TWinControl.ChildSizing"/>
      <element name="TForm.ClientHeight" link="#lcl.controls.TControl.ClientHeight"/>
      <element name="TForm.ClientWidth" link="#lcl.controls.TControl.ClientWidth"/>
      <element name="TForm.Color" link="#lcl.controls.TControl.Color"/>
      <element name="TForm.Constraints" link="#lcl.controls.TControl.Constraints"/>
      <element name="TForm.DefaultMonitor" link="#lcl.forms.TCustomForm.DefaultMonitor"/>
      <element name="TForm.DesignTimePPI" link="#lcl.forms.TCustomDesignControl.DesignTimePPI"/>
      <element name="TForm.DockSite" link="#lcl.controls.TWinControl.DockSite"/>
      <element name="TForm.DoubleBuffered" link="#lcl.controls.TControl.DoubleBuffered"/>
      <element name="TForm.DragKind" link="#lcl.controls.TControl.DragKind"/>
      <element name="TForm.DragMode" link="#lcl.controls.TControl.DragMode"/>
      <element name="TForm.Enabled" link="#lcl.controls.TControl.Enabled"/>
      <element name="TForm.Font" link="#lcl.controls.TControl.Font"/>
      <element name="TForm.FormStyle" link="#lcl.forms.TCustomForm.FormStyle"/>
      <element name="TForm.HelpFile" link="#lcl.forms.TCustomForm.HelpFile"/>
      <element name="TForm.Icon" link="#lcl.forms.TCustomForm.Icon"/>
      <element name="TForm.KeyPreview" link="#lcl.forms.TCustomForm.KeyPreview"/>
      <element name="TForm.Menu" link="#lcl.forms.TCustomForm.Menu"/>
      <element name="TForm.OnActivate" link="#lcl.forms.TCustomForm.OnActivate"/>
      <element name="TForm.OnChangeBounds" link="#lcl.controls.TControl.OnChangeBounds"/>
      <element name="TForm.OnClick" link="#lcl.controls.TControl.OnClick"/>
      <element name="TForm.OnClose" link="#lcl.forms.TCustomForm.OnClose"/>
      <element name="TForm.OnCloseQuery" link="#lcl.forms.TCustomForm.OnCloseQuery"/>
      <element name="TForm.OnContextPopup" link="#lcl.forms.TCustomForm.OnContextPopup"/>
      <element name="TForm.OnCreate" link="#lcl.forms.TCustomForm.OnCreate"/>
      <element name="TForm.OnDblClick" link="#lcl.controls.TControl.OnDblClick"/>
      <element name="TForm.OnDeactivate" link="#lcl.forms.TCustomForm.OnDeactivate"/>
      <element name="TForm.OnDestroy" link="#lcl.forms.TCustomForm.OnDestroy"/>
      <element name="TForm.OnDockDrop" link="#lcl.controls.TWinControl.OnDockDrop"/>
      <element name="TForm.OnDockOver" link="#lcl.controls.TWinControl.OnDockOver"/>
      <element name="TForm.OnDragDrop" link="#lcl.controls.TControl.OnDragDrop"/>
      <element name="TForm.OnDragOver" link="#lcl.controls.TControl.OnDragOver"/>
      <element name="TForm.OnDropFiles" link="#lcl.forms.TCustomForm.OnDropFiles"/>
      <element name="TForm.OnEndDock" link="#lcl.controls.TControl.OnEndDock"/>
      <element name="TForm.OnGetSiteInfo" link="#lcl.controls.TWinControl.OnGetSiteInfo"/>
      <element name="TForm.OnHelp" link="#lcl.forms.TCustomForm.OnHelp"/>
      <element name="TForm.OnHide" link="#lcl.forms.TCustomForm.OnHide"/>
      <element name="TForm.OnKeyDown" link="#lcl.controls.TWinControl.OnKeyDown"/>
      <element name="TForm.OnKeyPress" link="#lcl.controls.TWinControl.OnKeyPress"/>
      <element name="TForm.OnKeyUp" link="#lcl.controls.TWinControl.OnKeyUp"/>
      <element name="TForm.OnMouseDown" link="#lcl.controls.TControl.OnMouseDown"/>
      <element name="TForm.OnMouseEnter" link="#lcl.controls.TControl.OnMouseEnter"/>
      <element name="TForm.OnMouseLeave" link="#lcl.controls.TControl.OnMouseLeave"/>
      <element name="TForm.OnMouseMove" link="#lcl.controls.TControl.OnMouseMove"/>
      <element name="TForm.OnMouseUp" link="#lcl.controls.TControl.OnMouseUp"/>
      <element name="TForm.OnMouseWheel" link="#lcl.controls.TControl.OnMouseWheel"/>
      <element name="TForm.OnMouseWheelDown" link="#lcl.controls.TControl.OnMouseWheelDown"/>
      <element name="TForm.OnMouseWheelUp" link="#lcl.controls.TControl.OnMouseWheelUp"/>
      <element name="TForm.OnPaint" link="#lcl.controls.TCustomControl.OnPaint"/>
      <element name="TForm.OnResize" link="#lcl.controls.TControl.OnResize"/>
      <element name="TForm.OnShortCut" link="#lcl.forms.TCustomForm.OnShortcut"/>
      <element name="TForm.OnShow" link="#lcl.forms.TCustomForm.OnShow"/>
      <element name="TForm.OnShowHint" link="#lcl.controls.TControl.OnShowHint"/>
      <element name="TForm.OnStartDock" link="#lcl.controls.TControl.OnStartDock"/>
      <element name="TForm.OnUnDock" link="#lcl.controls.TWinControl.OnUnDock"/>
      <element name="TForm.OnUTF8KeyPress" link="#lcl.controls.TWinControl.OnUTF8KeyPress"/>
      <element name="TForm.OnWindowStateChange" link="#lcl.forms.TCustomForm.OnWindowStateChange"/>
      <element name="TForm.ParentBiDiMode" link="#lcl.controls.TControl.ParentBiDiMode"/>
      <element name="TForm.ParentDoubleBuffered" link="#lcl.controls.TControl.ParentDoubleBuffered"/>
      <element name="TForm.ParentFont" link="#lcl.controls.TControl.ParentFont"/>
      <element name="TForm.PixelsPerInch" link="#lcl.forms.TCustomForm.PixelsPerInch"/>
      <element name="TForm.PopupMenu" link="#lcl.controls.TControl.PopupMenu"/>
      <element name="TForm.PopupMode" link="#lcl.forms.TCustomForm.PopupMode"/>
      <element name="TForm.PopupParent" link="#lcl.forms.TCustomForm.PopupParent"/>
      <element name="TForm.Position" link="#lcl.forms.TCustomForm.Position"/>
      <element name="TForm.SessionProperties" link="#lcl.controls.TControl.SessionProperties"/>
      <element name="TForm.ShowHint" link="#lcl.controls.TControl.ShowHint"/>
      <element name="TForm.ShowInTaskBar" link="#lcl.forms.TCustomForm.ShowInTaskBar"/>
      <element name="TForm.UseDockManager" link="#lcl.controls.TWinControl.UseDockManager"/>
      <element name="TForm.LCLVersion">
        <short>The version of the LCL as string. Used to distinguish form streams using
          different versions of the LCL</short>
      </element>
      <element name="TForm.Scaled"/>
      <element name="TForm.Visible" link="#lcl.controls.TControl.Visible"/>
      <element name="TForm.WindowState" link="#lcl.forms.TCustomForm.WindowState"/>
      <!-- "class of" type Visibility: default -->
      <element name="TFormClass" link="#lcl.forms.TForm">
        <short>Class of <var>TForm</var></short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomDockForm">
        <short>A floating DockSite, usable to make TControls float</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.DoAddDockClient" link="#lcl.controls.TWinControl.DoAddDockClient">
        <short>Makes the client occupy the entire client area (alClient)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TCustomDockForm.DoAddDockClient.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.DoRemoveDockClient" link="#lcl.controls.TWinControl.DoRemoveDockClient">
        <short>Closes (releases) the form after the last client has been undocked</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.DoRemoveDockClient.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.GetSiteInfo" link="#lcl.controls.TWinControl.GetSiteInfo">
        <short>Disallows docking of an second client</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.Client">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.InfluenceRect">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.MousePos">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.CanDock">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.Loaded" link="#lcl.forms.TCustomForm.Loaded">
        <short>
          Tries to make all child controls dockclients. This is of little use in practice,
          a floating hostdocksite should have no child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomDockForm.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TCustomDockForm.Create.TheOwner">
        <short>Owner for the class instance</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomDockForm.AutoScroll" link="#lcl.forms.TScrollingWinControl.AutoScroll"/>
      <element name="TCustomDockForm.BorderStyle" link="#lcl.forms.TCustomForm.BorderStyle"/>
      <element name="TCustomDockForm.FormStyle" link="#lcl.forms.TCustomForm.FormStyle"/>
      <element name="TCustomDockForm.PixelsPerInch" link="#lcl.forms.TCustomForm.PixelsPerInch"/>
      <!-- object Visibility: default -->
      <element name="THintWindow">
        <short>
          The popup box containing helpful information that appears when the mouse pointer hovers over an object
        </short>
        <descr>
          <p>Usage:</p>
<code>
 HintWindow := THintWindow.Create(nil);
 Rect := HintWindow.CalcHintRect(0, 'This is the hint',nil);
 HintWindow.ActivateHint(Rect, 'This is the hint');
</code>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="THintWindow.FActivating">
        <short>True during ActivateHint</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.FAlignment" link="#lcl.forms.THintWindow.Alignment"/>
      <element name="THintWindow.FHintRect"/>
      <element name="THintWindow.FHintData"/>
      <element name="THintWindow.FAutoHide" link="#lcl.forms.THintWindow.AutoHide"/>
      <element name="THintWindow.FAutoHideTimer">
        <short>The timer used to make the hint disappear</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="THintWindow.FHideInterval" link="#lcl.forms.THintWindow.HideInterval"/>
      <element name="THintWindow.AdjustBoundsForMonitor">
        <short>Adjusts HintRect to fit on the current monitor</short>
        <descr>Used in the implementation of the OffsetHintRect method.</descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.HintRectAdjust"/>
          <link id="THintWindow.OffsetHintRect"/>
        </seealso>
      </element>
      <element name="THintWindow.AdjustBoundsForMonitor.KeepWidth">
        <short>Indicates that the width for HintRect should not be decreased</short>
      </element>
      <element name="THintWindow.AdjustBoundsForMonitor.KeepHeight">
        <short>Indicates that the height for HintRect should not be decreased</short>
      </element>
      <!-- function Visibility: private -->
      <element name="THintWindow.GetDrawTextFlags">
        <short>Collects the flags for Draw Text formatting</short>
        <descr>
          <p>
            Returns a Cardinal value that contains the Draw Text flags needed for the Alignment and BiDiMode used in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.Alignment"/>
          <link id="THintWindow.BiDiMode"/>
        </seealso>
      </element>
      <element name="THintWindow.GetDrawTextFlags.Result">
        <short>Draw Text flags for the hint window</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.SetAutoHide" link="#lcl.forms.THintWindow.AutoHide"/>
      <element name="THintWindow.SetAutoHide.Value">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.AutoHideHint">
        <short>Hides the hint window when the hint timer has expired</short>
        <descr>
          <p>
            Called when the hint timer expires. Ensures that the internal hint timer is disabled. Hides the hint window by setting the <var>Visible</var> property to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.AutoHide"/>
          <link id="THintWindow.HideInterval"/>
        </seealso>
      </element>
      <element name="THintWindow.AutoHideHint.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.SetHideInterval" link="#lcl.forms.THintWindow.HideInterval"/>
      <element name="THintWindow.SetHideInterval.Value">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.SetHintRectAdjust">
        <short>Sets the value for the HintRectAdjust property</short>
        <descr/>
        <seealso>
          <link id="THintWindow.HintRectAdjust"/>
        </seealso>
      </element>
      <element name="THintWindow.SetHintRectAdjust.AValue">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.WSRegisterClass" link="#lcl.lclclasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.WMNCHitTest">
        <short>Treats the whole window as transparent</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.WMNCHitTest.Message">
        <short/>
      </element>
      <element name="THintWindow.ActivateSub">
        <short>Sets the bounds for the hint window and configures the auto-hide timer</short>
        <descr>
          <p>
            Sets the bounds for the hint window to the values in the <var>HintRect</var> property, and makes the window <var>Visible</var>. The internal auto-hide timer is enabled when <var>AutoHide</var> contains <b>True</b>.
          </p>
          <p>
            Called from the ActivateHint method.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.AutoHide"/>
          <link id="THintWindow.ActivateHint"/>
          <link id="#lcl.controls.TControl.Visible">TControl.Visible</link>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.DoShowWindow" link="#lcl.forms.TCustomForm.DoShowWindow"/>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.UpdateRegion">
        <short>Updates the Window Region fir the hint window</short>
        <descr>
          <p>
            <var>UpdateRegion</var> calls the <var>SetWindowRgn</var> routine to set the window region for the hint window. The window region contains the area where the system can perform drawing operations; no area outside of the window region can be updated.
          </p>
          <remark>
            Please note: <var>SetWindowRgn</var> requires access to the Handle for the hint window; no actions are performed in the method when <var>HandleAllocated</var> returns <b>False</b>.
          </remark>
          <p>
            When <var>UseBGThemes</var> is enabled, <var>ThemeServices</var> are used to get the theme element details needed for the client rectangle in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.UseBGThemes"/>
          <link id="THintWindow.UseBGThemes"/>
        </seealso>
      </element>
      <element name="THintWindow.SetColor">
        <short>Sets the value for the Color property</short>
        <descr/>
        <seealso>
          <link id="#lcl.controls.TControl.Color">TControl.Color</link>
        </seealso>
      </element>
      <element name="THintWindow.SetColor.Value">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.UseBGThemes">
        <short>
          Indicates if a background from theme services is used when drawing the hint window
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.UseBGThemes.Result">
        <short>True when ThemeServices are used for the background</short>
      </element>
      <element name="THintWindow.UseFGThemes">
        <short>
          Indicates if theme services are used for the foreground rendered for the hint window
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.UseFGThemes.Result">
        <short>
          True when ThemeServices are used to draw the foreground for the hint window
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.Paint" link="#lcl.controls.TCustomControl.Paint"/>
      <element name="THintWindow.FSysHintFont"/>
      <element name="THintWindow.SysHintFont">
        <short>System font used to draw text in the hint window</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.SysHintFont.Result">
        <short>TFont instance for the system font provided by the widget set</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="THintWindow.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            Destroy is a class destructor. Destroy ensures a reference to the System Font used for hint windows is freed.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="THintWindow.Create" link="#rtl.classes.TComponent.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited <var>CreateNew</var> constructor, and allocates resources needed in the class instance. This includes an internal timer used when <var>AutoHide</var> is set to <b>True</b>.
          </p>
          <p>
            Create sets the default values for the following properties:
          </p>
          <dl>
            <dt>Parent</dt>
            <dd>Set to Nil</dd>
            <dt>Color</dt>
            <dd>Set to clInfoBk</dd>
            <dt>Font</dt>
            <dd>Uses the Screen.HintFont</dd>
            <dt>Canvas</dt>
            <dd>Uses the brush style bsClear</dd>
            <dt>Alignment</dt>
            <dd>Set to taLeftJustify</dd>
            <dt>BorderStyle</dt>
            <dd>Set to bsNone</dd>
            <dt>Caption</dt>
            <dd>Set to an empty string ('')</dd>
            <dt>HideInterval</dt>
            <dd>Set to 3000 milliseconds (3 seconds)</dd>
            <dt>AutoHide</dt>
            <dd>Set to False</dd>
          </dl>
          <p>
            Create uses the default size from the class type for the control to set the initial bounds for the hint window.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="THintWindow.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ActivateHint">
        <short>Shows the specified hint</short>
        <descr>
          <p>
            <var>ActivateHint</var> is an overloaded procedure used to display the Hint text specified in <var>AHint</var>. An overloaded variant allows the display area for the hint window to be specified in the <var>ARect</var> argument.
          </p>
          <remark>
            Please note: No actions are performed in the method if <var>ActivateHint</var> has been previously called with the same hint text and display area.
          </remark>
        </descr>
        <seealso>
          <link id="THintWindow.CalcHintRect"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateHint.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <element name="THintWindow.ActivateHint.ARect">
        <short>TRect with the display area for the hint window</short>
      </element>
      <element name="THintWindow.ActivateWithBounds">
        <short>Sets the bounds in HintRect and activates the hint window</short>
        <descr>
          <p>
            <var>ActivateWithBounds</var> is a procedure used to update the location and text for the hint window. ActivateWithBounds sets the value in <var>HintRect</var> to the value in the <var>ARect</var> argument. ActivateWithBounds calls <var>ActivateHint</var> using the value in <var>AHint</var> as the text displayed in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.ActivateHint"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateWithBounds.ARect">
        <short>Rectangle with the bounds assigned to HintRect</short>
      </element>
      <element name="THintWindow.ActivateWithBounds.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ActivateHintData">
        <short>
          An extended version of ActivateHint with additional data used for the hint display
        </short>
        <descr>
          <p>
            <var>ActivateHintData</var> is an extended version of <var>ActivateHint</var>. It provides the additional <var>AData</var> argument which contains a pointer to values which can be used to construct  the text displayed in the hint window.
           </p>
          <p>
            The implementation in <var>THintWindow</var> does not use the values in <var>AData</var>. The method must be overridden in a descendent class to use the additional hint data in <var>AData</var>.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.ActivateHint"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateHintData.ARect">
        <short>Display rectangle for the hint text</short>
      </element>
      <element name="THintWindow.ActivateHintData.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <element name="THintWindow.ActivateHintData.AData">
        <short>Pointer to additional data used to construct the hint text</short>
      </element>
      <!-- function Visibility: public -->
      <element name="THintWindow.CalcHintRect">
        <short>Determines the rectangle required for the hint display</short>
        <descr>
          <p>
            CalcHintRect determines the display rectangle required for the hint display. CalcHintRect uses the larger of the values in the length of the hint text, and the width of the hint window.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="THintWindow.CalcHintRect.Result">
        <short>Display area needed for the hint display</short>
      </element>
      <element name="THintWindow.CalcHintRect.MaxWidth">
        <short>Greater than zero, otherwise the full monitor width is used</short>
      </element>
      <element name="THintWindow.CalcHintRect.AHint">
        <short>Hint text used to derive the display area</short>
      </element>
      <element name="THintWindow.CalcHintRect.AData">
        <short>Pointer to additional data used to construct the hint text</short>
      </element>
      <element name="THintWindow.OffsetHintRect">
        <short>Moves the hint rectangle by the specified amounts</short>
        <descr/>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.HintRectAdjust"/>
        </seealso>
      </element>
      <element name="THintWindow.OffsetHintRect.Result">
        <short>
          True when the hint rectangle was successfully moved by the specified amounts
        </short>
      </element>
      <element name="THintWindow.OffsetHintRect.AOffset">
        <short>TPoint with the horizontal and vertical offets for the hint display</short>
      </element>
      <element name="THintWindow.OffsetHintRect.dy">
        <short>Additional vertical offset applied to the hint rectangle</short>
      </element>
      <element name="THintWindow.OffsetHintRect.KeepWidth">
        <short>Indicates the width for the hint rectanlge must be maintained</short>
      </element>
      <element name="THintWindow.OffsetHintRect.KeepHeight">
        <short>Indicates the height for the hint rectanlge must be maintained</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.InitializeWnd" link="#lcl.controls.TControl.InitializeWnd"/>
      <element name="THintWindow.IsHintMsg">
        <short>Indicates if the specified message is relevant to a hint window display</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.IsHintMsg.Result">
        <short/>
      </element>
      <element name="THintWindow.IsHintMsg.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ReleaseHandle">
        <short>Destroys an allocated handle for the widget</short>
        <seealso>
          <link id="#lcl.controls.TWinControl.DestroyHandle">TWinControl.DestroyHandle</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.SetBounds" link="#lcl.controls.TControl.InitializeWnd"/>
      <element name="THintWindow.SetBounds.ALeft">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.ATop">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.AWidth">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.AHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="THintWindow.GetControlClassDefaultSize" link="#lcl.controls.TControl.GetControlClassDefaultSize"/>
      <element name="THintWindow.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <element name="THintWindow.OnMouseDown" link="#lcl.controls.TControl.OnMouseDown"/>
      <element name="THintWindow.OnMouseUp" link="#lcl.controls.TControl.OnMouseUp"/>
      <element name="THintWindow.OnMouseMove" link="#lcl.controls.TControl.OnMouseMove"/>
      <element name="THintWindow.OnMouseLeave" link="#lcl.controls.TControl.OnMouseLeave"/>
      <!-- property Visibility: public -->
      <element name="THintWindow.Alignment">
        <short>Text alignment used for the hint window</short>
        <descr>
          <p>
            <var>Alignment</var> is a <var>TAlignment</var> property that indicates the alignment used for the text displayed in the hint window.
          </p>
          <p>
            The default value for the property is <var>taLeftJustify</var>, as assigned in the <var>Create</var> constructor. The value in Alignment is used to derive the draw text flags required for the <var>BidiMode</var> in the hint display, and passed to to <var>DrawText</var> routine in theme services or widget set classes.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.BiDiMode"/>
          <link id="TAlignment"/>
        </seealso>
      </element>
      <element name="THintWindow.HintRect">
        <short>Contains the bounds used to display the text for the hint</short>
        <descr>
          <p>
            <var>HintRect</var> is a <var>TRect</var> property which contains the bounds used to display the hint when it is activated. <var>HintRect</var> is adjusted using the values in <var>HintRectAdjust</var> (when assigned) and the borders drawn around the hint display.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.ActivateHint"/>
          <link id="THintWindow.ActivateHintData"/>
          <link id="THintWindow.ActivateWithBounds"/>
          <link id="THintWindow.HintRectAdjust"/>
        </seealso>
      </element>
      <element name="THintWindow.HintRectAdjust">
        <short>Contains the bounds with additional space used for the hint display</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.HintData">
        <short>Pointer to data used to formulate text displayed in the hint window</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="THintWindow.AutoHide">
        <short>Does the hint disappear (get hidden) after a while?</short>
        <descr>
          If <var>AutoHide</var> is TRUE, the hint disappears after an interval specified by
          <link id="THintWindow.HideInterval">HideInterval</link>.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="THintWindow.BiDiMode" link="#lcl.controls.TControl.BiDiMode"/>
      <!-- property Visibility: public -->
      <element name="THintWindow.HideInterval">
        <short>The time after which the displayed hint disappears</short>
        <descr/>
        <seealso>
          <link id="THintWindow.AutoHide"/>
        </seealso>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="THintWindowClass" link="#lcl.forms.THintWindow">
        <short>Class of <var>THintWindow</var></short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindowRendered">
        <short>For a rendered hint with a child control added by an external provider</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindowRendered.Create">
        <short>Constructor for the class instance</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindowRendered.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="THintWindowRendered.Destroy">
        <short>Destructor for the class instance</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindowRendered.ActivateRendered">
        <short>Shows hint contents are rendered by a provider on child control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TMonitor">
        <short>Provides information about a physical monitor</short>
        <descr>
          <p>
            Monitor information is retrieved dynamically from the Operating System. This ensures that any changes to the installed hardware devices or their configuration are taken into account. <var>TMonitor</var> has properties that reflect its dimensions, use as the primary monitor, and its display density (or Pixels per Inch).
          </p>
          <p>
            <var>TMonitor</var> is the type returned when reading the <var>TScreen.Monitors</var> property. <var>TMonitor</var> is the type used to implement the <var>TCustomForm.Monitor</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Monitor"/>
          <link id="TScreen.Monitors"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TMonitor.FHandle" link="#lcl.forms.TMonitor.Handle"/>
      <element name="TMonitor.FMonitorNum" link="#lcl.forms.TMonitor.MonitorNum"/>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetInfo">
        <short>Retrieves monitor information from the OS or platform</short>
        <descr>
          <p>
            <var>Getinfo</var> is a <var>Boolean</var> function used to get monitor information from the OS or platform hosting the LCL application. <var>Getinfo</var> initializes the <var>Info</var> output parameter to the size required for the <var>TMonitorInfo</var> type, and calls the <var>GetMonitorInfo</var> routine for the widget set.
          </p>
          <p>
            The return value is <b>True</b> when monitor information is successfully retrieved for the OS or platform. <var>Info</var> contains the size, display rectangle, work area, and flags for the monitor.
          </p>
        </descr>
        <seealso>
          <link id="#lcl.lcltype.TMonitorInfo">TMonitorInfo</link>
        </seealso>
      </element>
      <element name="TMonitor.GetInfo.Result">
        <short>True when monitor information was successfully retrieved</short>
      </element>
      <element name="TMonitor.GetInfo.Info">
        <short>TMonitorInfo with values retrieved for the OS or platform</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetLeft">
        <short>Gets the value for the Left property</short>
        <descr/>
        <seealso>
          <link id="TMonitor.Left"/>
        </seealso>
      </element>
      <element name="TMonitor.GetLeft.Result">
        <short>Value for the property</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetHeight" link="#lcl.forms.TMonitor.Height"/>
      <element name="TMonitor.GetHeight.Result">
        <short/>
      </element>
      <element name="TMonitor.GetPixelsPerInch">
        <short>Gets the value for the PixelsPerInch property</short>
        <descr/>
        <seealso>
          <link id="TMonitor.PixelsPerInch"/>
        </seealso>
      </element>
      <element name="TMonitor.GetPixelsPerInch.Result">
        <short>Value for the property</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetTop" link="#lcl.forms.TMonitor.Top"/>
      <element name="TMonitor.GetTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetWidth" link="#lcl.forms.TMonitor.Width"/>
      <element name="TMonitor.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetBoundsRect" link="#lcl.forms.TMonitor.BoundsRect"/>
      <element name="TMonitor.GetBoundsRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetWorkareaRect" link="#lcl.forms.TMonitor.WorkareaRect"/>
      <element name="TMonitor.GetWorkareaRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetPrimary" link="#lcl.forms.TMonitor.Primary"/>
      <element name="TMonitor.GetPrimary.Result">
        <short/>
      </element>
      <element name="TMonitor.Handle">
        <short>Handle which identifies this monitor to the system</short>
      </element>
      <element name="TMonitor.MonitorNum">
        <short>Index of the monitor in the <link id="TScreen.Monitors"/> list</short>
      </element>
      <element name="TMonitor.Left">
        <short>The leftmost screen coordinate of the display</short>
      </element>
      <element name="TMonitor.Height">
        <short>The height of the display</short>
      </element>
      <element name="TMonitor.Top">
        <short>The topmost screen coordinate of the display</short>
      </element>
      <element name="TMonitor.Width">
        <short>The width of the display</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TMonitor.BoundsRect">
        <short>The logical dimensions of the monitor, within the desktop.
        </short>
      </element>
      <element name="TMonitor.WorkareaRect">
        <short>The usable display area, excluding a taskbar etc</short>
      </element>
      <element name="TMonitor.Primary">
        <short>True if this is the primary monitor of the system</short>
      </element>
      <element name="TMonitor.PixelsPerInch">
        <short>Contains the Pixels Per Inch or display density for the monitor</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TMonitorList">
        <short>A list of all available monitors</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitorList.GetItem" link="#lcl.forms.TMonitorList.Items"/>
      <element name="TMonitorList.GetItem.Result">
        <short/>
      </element>
      <element name="TMonitorList.GetItem.AIndex">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMonitorList.SetItem" link="#lcl.forms.TMonitorList.Items"/>
      <element name="TMonitorList.SetItem.AIndex">
        <short/>
      </element>
      <element name="TMonitorList.SetItem.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TMonitorList.Notify">
        <short>
          List notification handler, destroys the Monitor object on removal from the list
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TMonitorList.Notify.Ptr">
        <short>The monitor object</short>
      </element>
      <element name="TMonitorList.Notify.Action">
        <short>The list operation</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TMonitorList.Items">
        <short>The indexed list of all Monitors</short>
        <descr>
          Items is the default property for the monitor list.
        </descr>
        <seealso/>
      </element>
      <element name="TMonitorList.Items.AIndex">
        <short>Ordinal position for a monitor in the list</short>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PCursorRec" link="#lcl.forms.TCursorRec"/>
      <!-- record type Visibility: default -->
      <element name="TCursorRec">
        <short>An element of the Cursor list</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Next">
        <short>The next list element</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Index">
        <short>The list index</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Handle">
        <short>The OS identifier for this cursor</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TScreenFormEvent">
        <short>Type used for a screen notification handler, for form related events</short>
        <descr/>
        <seealso>
          <link id="TScreenNotification"/>
          <link id="TScreenControlEvent"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenFormEvent.Sender">
        <short>TObject for the event notification</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenFormEvent.Form">
        <short>The affected form</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TScreenControlEvent">
        <short>Type for a screen notification handler used for control related events</short>
        <descr/>
        <seealso>
          <link id="TScreenFormEvent"/>
          <link id="TScreenNotification"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenControlEvent.Sender">
        <short>TObject for the event notification</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenControlEvent.LastControl">
        <short>The <b>new</b> active control</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScreenNotification">
        <short>Screen notification events and handler types</short>
        <descr/>
        <seealso>
          <link id="TScreenFormEvent"/>
          <link id="TScreenControlEvent"/>
        </seealso>
      </element>
      <element name="TScreenNotification.snFormAdded">
        <short>A form was added</short>
      </element>
      <element name="TScreenNotification.snRemoveForm">
        <short>A form was removed</short>
      </element>
      <element name="TScreenNotification.snActiveControlChanged">
        <short>The focus moved to another control</short>
      </element>
      <element name="TScreenNotification.snActiveFormChanged">
        <short>The focus moved to another form</short>
      </element>
      <element name="TScreenNotification.snFormVisibleChanged">
        <short>The visibility of a form changed</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TMonitorDefaultTo">
        <short>
          The monitor to use when screen coordinates are outside of the physical screen bounds
        </short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TMonitorDefaultTo.mdNearest">
        <short>Default to the nearest monitor</short>
      </element>
      <element name="TMonitorDefaultTo.mdNull">
        <short>Default to Nil (no suggested monitor)</short>
      </element>
      <element name="TMonitorDefaultTo.mdPrimary">
        <short>Default to the primary monitor</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TScreen">
        <short>Provides information about the display and related objects</short>
        <descr>
          <p>
            The virtual screen (desktop) can include multiple <link id="TScreen.Monitors">physical Monitors</link>. Screen objects are Cursors, Fonts and Forms. For Delphi compatibility, non-visual  DataModules are included.
          </p>
          <p>The currently active Form, Control and Cursor also are tracked.</p>
        </descr>
        <seealso>
          <link id="TScreen.Cursors"/>
          <link id="TScreen.DataModules"/>
          <link id="TScreen.DesktopRect"/>
          <link id="TScreen.Fonts"/>
          <link id="TScreen.Forms"/>
          <link id="TScreen.Monitors"/>
          <link id="TScreen.WorkareaRect"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScreen.FActiveControl" link="#lcl.forms.TScreen.ActiveControl"/>
      <element name="TScreen.FActiveCustomForm" link="#lcl.forms.TScreen.ActiveCustomForm"/>
      <element name="TScreen.FActiveForm" link="#lcl.forms.TScreen.ActiveForm"/>
      <element name="TScreen.FCursor" link="#lcl.forms.TScreen.Cursor"/>
      <element name="TScreen.FCursorMap" link="#lcl.forms.TScreen.Cursors"/>
      <element name="TScreen.FCustomForms" link="#lcl.forms.TScreen.CustomForms"/>
      <element name="TScreen.FCustomFormsZOrdered" link="#lcl.forms.TScreen.CustomFormsZOrdered"/>
      <element name="TScreen.FDefaultCursor"/>
      <!-- variable Visibility: private -->
      <element name="TScreen.FHintFont" link="#lcl.forms.TScreen.HintFont"/>
      <element name="TScreen.FFocusedForm" link="#lcl.forms.TScreen.FocusedForm"/>
      <element name="TScreen.FFonts" link="#lcl.forms.TScreen.Fonts"/>
      <element name="TScreen.FFormList" link="#lcl.forms.TScreen.Forms"/>
      <element name="TScreen.FDataModuleList" link="#lcl.forms.TScreen.DataModules"/>
      <element name="TScreen.FIconFont" link="#lcl.forms.TScreen.IconFont"/>
      <element name="TScreen.FMenuFont" link="#lcl.forms.TScreen.MenuFont"/>
      <element name="TScreen.FScreenHandlers"/>
      <element name="TScreen.FLastActiveControl">
        <short>The last active control, used to detect focus changes</short>
        <seealso>
          <link id="TScreen.RestoreLastActive"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScreen.FLastActiveCustomForm">
        <short>The last active form, used to detect focus changes</short>
        <descr/>
        <seealso>
          <link id="TScreen.RestoreLastActive"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScreen.FMonitors" link="#lcl.forms.TScreen.Monitors"/>
      <element name="TScreen.FOnActiveControlChange" link="#lcl.forms.TScreen.OnActiveControlChange"/>
      <element name="TScreen.FOnActiveFormChange" link="#lcl.forms.TScreen.OnActiveFormChange"/>
      <element name="TScreen.FPixelsPerInch" link="#lcl.forms.TScreen.PixelsPerInch"/>
      <element name="TScreen.FSaveFocusedList"/>
      <element name="TScreen.FSystemFont" link="#lcl.forms.TScreen.SystemFont"/>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DeleteCursor">
        <short>Removes a cursor from the Cursors property</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.DeleteCursor.AIndex">
        <short>The logical cursor ID</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DestroyCursors">
        <short>Deletes all TCursor instances in the Cursors property</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DestroyMonitors">
        <short>Clears the Monitors list</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCursors" link="#lcl.forms.TScreen.Cursors"/>
      <element name="TScreen.GetCursors.Result">
        <short/>
      </element>
      <element name="TScreen.GetCursors.AIndex">
        <short>The logical cursor ID</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormCount" link="#lcl.forms.TScreen.CustomFormCount"/>
      <element name="TScreen.GetCustomFormCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormZOrderCount" link="#lcl.forms.TScreen.CustomFormZOrderCount"/>
      <element name="TScreen.GetCustomFormZOrderCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomForms" link="#lcl.forms.TScreen.CustomForms"/>
      <element name="TScreen.GetCustomForms.Result">
        <short/>
      </element>
      <element name="TScreen.GetCustomForms.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormsZOrdered" link="#lcl.forms.TScreen.CustomFormZOrdered"/>
      <element name="TScreen.GetCustomFormsZOrdered.Result">
        <short/>
      </element>
      <element name="TScreen.GetCustomFormsZOrdered.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDataModuleCount" link="#lcl.forms.TScreen.DataModuleCount"/>
      <element name="TScreen.GetDataModuleCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDataModules" link="#lcl.forms.TScreen.DataModules"/>
      <element name="TScreen.GetDataModules.Result">
        <short/>
      </element>
      <element name="TScreen.GetDataModules.AIndex">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopLeft" link="#lcl.forms.TScreen.DesktopLeft"/>
      <element name="TScreen.GetDesktopLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopTop" link="#lcl.forms.TScreen.DesktopTop"/>
      <element name="TScreen.GetDesktopTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopHeight" link="#lcl.forms.TScreen.DesktopHeight"/>
      <element name="TScreen.GetDesktopHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopWidth" link="#lcl.forms.TScreen.DesktopWidth"/>
      <element name="TScreen.GetDesktopWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopRect" link="#lcl.forms.TScreen.DesktopRect"/>
      <element name="TScreen.GetDesktopRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetFonts" link="#lcl.forms.TScreen.Fonts"/>
      <element name="TScreen.GetFonts.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetFormCount" link="#lcl.forms.TScreen.FormCount"/>
      <element name="TScreen.GetFormCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetForms" link="#lcl.forms.TScreen.Forms"/>
      <element name="TScreen.GetForms.Result">
        <short/>
      </element>
      <element name="TScreen.GetForms.IIndex">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetHeight" link="#lcl.forms.TScreen.Height"/>
      <element name="TScreen.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetMonitor" link="#lcl.forms.TScreen.Monitors"/>
      <element name="TScreen.GetMonitor.Result">
      <short/>
      </element>
      <element name="TScreen.GetMonitor.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetMonitorCount" link="#lcl.forms.TScreen.MonitorCount"/>
      <element name="TScreen.GetMonitorCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetPrimaryMonitor" link="#lcl.forms.TScreen.PrimaryMonitor"/>
      <element name="TScreen.GetPrimaryMonitor.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWidth" link="#lcl.forms.TScreen.Width"/>
      <element name="TScreen.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.AddForm">
        <short>Internal notification handler, adds a new form to the lists</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddForm.AForm">
        <short>Form instance added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RemoveForm">
        <short>Internal notification handler, removes the form from the lists</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveForm.AForm">
        <short>Form instance removed from the list</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.SetFocusedForm" link="#lcl.forms.TScreen.FocusedForm"/>
      <element name="TScreen.SetFocusedForm.Result">
        <short/>
      </element>
      <element name="TScreen.SetFocusedForm.AForm">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetCursor" link="#lcl.forms.TScreen.Cursor"/>
      <element name="TScreen.SetCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetCursors" link="#lcl.forms.TScreen.Cursors"/>
      <element name="TScreen.SetCursors.AIndex">
        <short/>
      </element>
      <element name="TScreen.SetCursors.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetHintFont" link="#lcl.forms.TScreen.HintFont"/>
      <element name="TScreen.SetHintFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetIconFont" link="#lcl.forms.TScreen.IconFont"/>
      <element name="TScreen.SetIconFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetMenuFont" link="#lcl.forms.TScreen.MenuFont"/>
      <element name="TScreen.SetMenuFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetSystemFont" link="#lcl.forms.TScreen.SystemFont"/>
      <element name="TScreen.SetSystemFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.UpdateLastActive">
        <short>
          Stores the currently active form and control in the last active members.
          Notifies all registered handlers of eventual changes.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RestoreLastActive">
        <short>Moves the Focus back to the previously focused control</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.AddHandler">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandler.HandlerType">
        <short>The notification (event) type</short>
      </element>
      <element name="TScreen.AddHandler.Handler">
        <short>The notification handler</short>
      </element>
      <element name="TScreen.AddHandler.AsFirst">
        <short>Add the handler as the first (True) or last (False) handler</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RemoveHandler">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandler.HandlerType">
        <short>The notification (event) type</short>
      </element>
      <element name="TScreen.RemoveHandler.Handler">
        <short>The notification handler</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DoAddDataModule" link="#lcl.forms.TScreen.DataModules">
        <short>Adds the specified DataModule to the list</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TScreen.DoAddDataModule.DataModule">
        <short>Data module instance added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DoRemoveDataModule" link="#lcl.forms.TScreen.DataModules">
        <short>Removes the specified DataModule from the list</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TScreen.DoRemoveDataModule.DataModule">
        <short>Data module removed in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.NotifyScreenFormHandler">
        <short>Notifies all registered handlers for the given event</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TScreen.NotifyScreenFormHandler.HandlerType">
        <short>Event type for the notification</short>
      </element>
      <element name="TScreen.NotifyScreenFormHandler.Form">
        <short>Form instance for the notification</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaHeight" link="#lcl.forms.TScreen.WorkAreaHeight"/>
      <element name="TScreen.GetWorkAreaHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaLeft" link="#lcl.forms.TScreen.WorkAreaLeft"/>
      <element name="TScreen.GetWorkAreaLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaRect" link="#lcl.forms.TScreen.WorkAreaRect"/>
      <element name="TScreen.GetWorkAreaRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaTop" link="#lcl.forms.TScreen.WorkAreaTop"/>
      <element name="TScreen.GetWorkAreaTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaWidth" link="#lcl.forms.TScreen.WorkAreaWidth"/>
      <element name="TScreen.GetWorkAreaWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetHintFont" link="#lcl.forms.TScreen.HintFont"/>
      <element name="TScreen.GetHintFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetIconFont" link="#lcl.forms.TScreen.IconFont"/>
      <element name="TScreen.GetIconFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetMenuFont" link="#lcl.forms.TScreen.MenuFont"/>
      <element name="TScreen.GetMenuFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetSystemFont" link="#lcl.forms.TScreen.SystemFont"/>
      <element name="TScreen.GetSystemFont.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TScreen.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TScreen.Create.AOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TScreen.Destroy"/>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormIndex" link="#lcl.forms.TScreen.CustomForms">
        <short>The ordinal position in CustomForms the requested form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.CustomFormIndex.Result">
        <short>The form Index, -1 if not found</short>
      </element>
      <element name="TScreen.CustomFormIndex.AForm">
        <short>The Form to which the Index refers</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FormIndex">
        <short>The ordinal position in Forms for the requested form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.FormIndex.Result">
        <short>The form Index, -1 if not found</short>
      </element>
      <element name="TScreen.FormIndex.AForm">
        <short>The Form to which the Index refers</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormZIndex">
        <short>The index of the form  in the Z dimension (Front to Back)</short>
        <descr>
          <p>
            The return value contains the activation order for the specified form, with the currently active form at index position zero (<b>0</b>).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TScreen.CustomFormZIndex.Result">
        <short/>
      </element>
      <element name="TScreen.CustomFormZIndex.AForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.MoveFormToFocusFront">
        <short>Moves the specified form to the front of all form lists</short>
        <descr/>
        <errors>
          Raises a GDB exception when the form is being destroyed, or the application is shutting down.
        </errors>
        <seealso/>
      </element>
      <element name="TScreen.MoveFormToFocusFront.ACustomForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.MoveFormToZFront">
        <short>Moves the form to the front of the Z-order list (notification only)</short>
        <descr/>
        <errors>
          Raises a GDB exception when the form is being destroyed, or the application is shutting down.
        </errors>
        <seealso>
          <link id="TScreen.MoveFormToFocusFront"/>
        </seealso>
      </element>
      <element name="TScreen.MoveFormToZFront.ACustomForm">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.GetCurrentModalForm">
        <short>
          Returns the topmost Modal form (i.e. a form that is awaiting a user response).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.GetCurrentModalForm.Result">
        <short>The modal form, or Nil if none is active</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.GetCurrentModalFormZIndex">
        <short>Returns the index of the topmost modal form in CustomFormsZOrdered[]</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.GetCurrentModalFormZIndex.Result">
        <short>The index for the form, or -1 if no modal form is active</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormBelongsToActiveGroup">
        <short>
          Checks whether the form is visible, and whether modal or not blocked by
          another modal form
        </short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TScreen.CustomFormBelongsToActiveGroup.Result">
        <short/>
      </element>
      <element name="TScreen.CustomFormBelongsToActiveGroup.AForm">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindNonDesignerForm">
        <short>Finds the named form, excluding designer forms</short>
        <descr/>
        <seealso>
          <link id="TScreen.FindForm"/>
        </seealso>
      </element>
      <element name="TScreen.FindNonDesignerForm.Result">
        <short/>
      </element>
      <element name="TScreen.FindNonDesignerForm.FormName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindForm">
        <short>Finds a form by its name</short>
        <descr/>
        <seealso>
          <link id="TScreen.FindNonDesignerForm"/>
        </seealso>
      </element>
      <element name="TScreen.FindForm.Result">
        <short/>
      </element>
      <element name="TScreen.FindForm.FormName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindNonDesignerDataModule">
        <short>Finds the named DataModule, excluding designer modules</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.FindDataModule"/>
        </seealso>
      </element>
      <element name="TScreen.FindNonDesignerDataModule.Result">
        <short/>
      </element>
      <element name="TScreen.FindNonDesignerDataModule.DataModuleName">
        <short/>
      </element>
      <element name="TScreen.FindDataModule.Result">
        <short/>
      </element>
      <element name="TScreen.FindDataModule.DataModuleName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.FindDataModule">
        <short>Finds the named DataModule</short>
        <seealso>
          <link id="TScreen.FindNonDesignerDataModule"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.UpdateMonitors">
        <short>Builds the list of available monitors</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.UpdateScreen">
        <short>Updates the <link id="TScreen.PixelsPerInch"/> property</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveAllHandlersOfObject" link="#lcl.lclclasses.TLCLComponent.RemoveAllHandlersOfObject"/>
      <element name="TScreen.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerFormAdded">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerFormAdded.OnFormAdded">
        <short/>
      </element>
      <element name="TScreen.AddHandlerFormAdded.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerFormAdded">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerFormAdded.OnFormAdded">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerRemoveForm">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerRemoveForm.OnRemoveForm">
        <short/>
      </element>
      <element name="TScreen.AddHandlerRemoveForm.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerRemoveForm">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerRemoveForm.OnRemoveForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerActiveControlChanged">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerActiveControlChanged.OnActiveControlChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerActiveControlChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerActiveControlChanged">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerActiveControlChanged.OnActiveControlChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerActiveFormChanged">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerActiveFormChanged.OnActiveFormChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerActiveFormChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerActiveFormChanged">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerActiveFormChanged.OnActiveFormChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerFormVisibleChanged">
        <short>Adds a notification handler</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerFormVisibleChanged.OnFormVisibleChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerFormVisibleChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerFormVisibleChanged">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerFormVisibleChanged.OnFormVisibleChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.DisableForms">
        <short>
          Disables all forms except <var>SkipForm</var>.
        </short>
        <descr>
          <p>Used to show modal forms or dialogs.</p>
          <p>The enabled state is determined from the widget, not from LCL properties.</p>
          <p>If <var>DisabledList</var> is Nil, a new list is created. Then all disabled forms
           are added to that list.</p>
           <p>When the modal form returns, call EnableForms to restore all forms.</p>
        </descr>
        <seealso>
          <link id="TScreen.EnableForms"/>
        </seealso>
      </element>
      <element name="TScreen.DisableForms.Result">
        <short>The list containing all disabled forms</short>
      </element>
      <element name="TScreen.DisableForms.SkipForm">
        <short>Don't disable this form (ignored if Nil)</short>
      </element>
      <element name="TScreen.DisableForms.DisabledList">
        <short>The list to update. If Nil, a new list is created and returned</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.EnableForms">
        <short>
          Use this method to restore all <link id="TScreen.DisableForms">previously disabled</link> forms.
        </short>
        <seealso>
          <link id="TScreen.DisableForms"/>
        </seealso>
      </element>
      <element name="TScreen.EnableForms.AFormList">
        <short>The list containing the forms to enable. The list is destroyed on exit.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromPoint">
          <short>Find the monitor containing the given screen coordinates</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.MonitorFromRect"/>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromPoint.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromPoint.Point">
        <short>The screen coordinates to find</short>
      </element>
      <element name="TScreen.MonitorFromPoint.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromRect">
        <short>Find the monitor containing (most of) the given screen coordinates</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.MonitorFromPoint"/>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromRect.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromRect.Rect">
        <short>The screen coordinates to find</short>
      </element>
      <element name="TScreen.MonitorFromRect.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromWindow">
        <short>Finds the monitor containing (most of) the given window handle</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromWindow.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromWindow.Handle">
        <short>The window handle to use</short>
      </element>
      <element name="TScreen.MonitorFromWindow.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <element name="TScreen.BeginTempCursor">
        <short>Override the Cursor property with a temporary value. Use EndTempCursor to release it.</short>
      </element>
      <element name="TScreen.BeginTempCursor.aCursor">
        <short/>
      </element>
      <element name="TScreen.EndTempCursor">
        <short>Release the temporary cursor set with BeginTempCursor.</short>
      </element>
      <element name="TScreen.EndTempCursor.aCursor">
        <short/>
      </element>
      <element name="TScreen.BeginWaitCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.EndWaitCursor">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveControl">
        <short>The control which has the Focus for the screen</short>
        <descr/>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveCustomForm">
        <short>The custom form which has the Focus</short>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveForm">
        <short>The form which has the Focus</short>
        <seealso>
          <link id="TScreen.ActiveControl"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Cursor">
        <short>The current mouse cursor shape</short>
        <descr>Use one of the predefined cursor styles, e.g. crHourGlass.</descr>
        <seealso>
          <link id="Controls.crDefault"/>
        </seealso>
      </element>
      <element name="TScreen.RealCursor">
        <short>Gets the value for the Cursor property taking temporary cursors into account</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Cursors">
        <short>Provides indexed access to the available cursor shapes for the screen</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreen.Cursors.Index">
        <short>Ordinal position for the value requested</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormCount">
        <short>The number of Custom Forms</short>
        <seealso>
          <link id="TScreen.CustomForms"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomForms">
        <short>Provides indexed access to the list of Custom Forms for the screen</short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormCount"/>
        </seealso>
      </element>
      <element name="TScreen.CustomForms.Index">
        <short>Ordinal position for the requested form</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormsZOrdered">
        <short>The list of Custom Forms, indexed by Z-order (zero is topmost)</short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormZOrderCount"/>
        </seealso>
      </element>
      <element name="TScreen.CustomFormsZOrdered.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormZOrderCount">
        <short>
          <var>CustomFormZOrderCount</var> - the number of forms arranged in Z-plane order (i.e. Front to Back)
        </short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormsZOrdered"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopLeft" link="#lcl.forms.TScreen.DesktopRect">
        <short>The leftmost coordinate of the desktop</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopTop" link="#lcl.forms.TScreen.DesktopRect">
        <short>The topmost coordinate of the desktop</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopHeight" link="#lcl.forms.TScreen.DesktopRect">
        <short>The total vertical size of the desktop</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopWidth" link="#lcl.forms.TScreen.DesktopRect">
        <short>The total horizontal size of the display</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopRect">
        <short>The total extent of the desktop, spanning all monitors</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.FocusedForm">
        <short>The form that holds Focus</short>
        <descr/>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
        <notes><note>really?</note><note>what's different from ActiveForm?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.FormCount" link="#lcl.forms.TScreen.Forms">
        <short>The number of existing Forms</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Forms">
        <short>The indexed list of all Forms, in Z-order</short>
        <descr/>
        <seealso>
          <link id="TScreen.FormCount"/>
          <link id="TScreen.CustomForms"/>
        </seealso>
      </element>
      <element name="TScreen.Forms.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DataModuleCount">
        <short>The number of existing data modules</short>
        <seealso>
          <link id="TScreen.DataModules"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DataModules">
        <short>The indexed list of Data Modules</short>
        <seealso>
          <link id="TScreen.DataModuleCount"/>
        </seealso>
      </element>
      <element name="TScreen.DataModules.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.HintFont">
        <short>The font used to display Hints</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.IconFont">
        <short>The Icon font, used for desktop icons</short>
        <descr>
          IconFont is passed to the InitStockFont method in the widgetset to load the font required.
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.MenuFont">
        <short>The font used in menus</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.SystemFont">
        <short>
          The default font used for system task dialogs and controls like TSpeedButton
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Fonts">
        <short>The names of the available (installed) fonts</short>
        <descr>
          <p>
            <var>Fonts</var> is a read-only <var>TStrings</var> property which contains the names for the fonts available using the <var>EnumFontFamiliesEx</var> routine for the widgetset. Values in Fonts are sorted alphabetically in ascending order.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Height">
        <short>The height of the primary monitor</short>
        <seealso>
          <link id="TScreen.PrimaryMonitor"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.MonitorCount" link="#lcl.forms.TScreen.Monitors">
        <short>The number of available Monitors</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Monitors">
        <short>The indexed list of available monitors.
        </short>
        <seealso>
          <link id="TScreen.MonitorCount"/>
        </seealso>
      </element>
      <element name="TScreen.Monitors.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.PixelsPerInch">
        <short>
          The number of screen pixels for an virtual inch (DPI), in the vertical direction.
        </short>
        <descr>
          <p>
            The display uses virtual inches, which typically are bigger than physical inches. This requires that text appear bigger on a screen than on a printer.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.PrimaryMonitor">
        <short>The primary monitor typically shows the taskbar</short>
        <seealso>
          <link id="TScreen.WorkareaRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Width">
        <short>The width of the primary monitor</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaRect">
        <short>The usable display area on the primary monitor, excluding e.g. the taskbar</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.DesktopRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaHeight" link="#lcl.forms.TScreen.WorkareaRect">
        <short>The usable height of the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaLeft" link="#lcl.forms.TScreen.WorkareaRect">
        <short>The usable left coordinate on the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaTop" link="#lcl.forms.TScreen.WorkareaRect">
        <short>The usable top coordinate on the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaWidth" link="#lcl.forms.TScreen.WorkareaRect">
        <short>The usable width of the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.OnActiveControlChange">
        <short>Handler for a Focus changed notification</short>
        <descr/>
        <seealso>
          <link id="TScreen.AddHandlerActiveControlChanged"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.OnActiveFormChange">
        <short>Handler for a Focus changed notification</short>
        <descr/>
        <seealso>
          <link id="TScreen.AddHandlerActiveFormChanged"/>
        </seealso>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TQueryEndSessionEvent">
        <short>The type of an <link id="TApplication.OnQueryEndSession"/> handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TQueryEndSessionEvent.Cancel">
        <short>Set Cancel to True to prevent a logoff</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TExceptionEvent">
        <short>
          Defines an event handler signalled to perform exception handling in an application
        </short>
        <descr>
          <p>
            <var>TExceptionEvent</var> is an object procedure type that defines an event handler signalled to perform exception handling in an application. Arguments passed to the event handler identify the application generating the notification, and the exception class instance. Applications must implement an object procedure using the signature for the event, and assign it to an event handler to respond to the notification.
          </p>
          <p>
            <var>TExceptionEvent</var> is the type used to implement exception handlers in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplicationProperties.OnException"/>
        </seealso>
      </element>
      <element name="TExceptionEvent.Sender">
        <short>Object instance for the notification</short>
      </element>
      <element name="TExceptionEvent.E">
        <short>Exception instance for the notification</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetHandleEvent">
        <short>
          Specifies an event handler used to get the handle for the main form in an application
        </short>
        <descr>
          <p>
            <var>TGetHandleEvent</var> is an object procedure type which defines an event handler signalled to get the handle for the main form in an application. <var>TGetHandleEvent</var> is the type used to implement the <var>OnGetMainFormHandle</var> event handler in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
          <link id="TApplication.AddOnGetMainFormHandleHandler"/>
          <link id="TApplication.RemoveOnGetMainFormHandleHandler"/>
        </seealso>
      </element>
      <element name="TGetHandleEvent.Handle">
        <short>Handle for the form instance used as the main form</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TIdleEvent">
        <short>Type of an Idle event handler</short>
        <descr>
          <p>
            Lengthy operations should be broken into smaller parts, to ensure that the application remains responsive. The handlers are called repeatedly, until all signal Done.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TIdleEvent.Sender">
        <short/>
      </element>
      <element name="TIdleEvent.Done">
        <short>Set to True when everything is done</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TOnUserInputEvent">
        <short>
          Specifies an event handler signalled to respond to user input messages in an application
        </short>
        <descr>
          <p>
            <var>TOnUserInputEvent</var> is an object procedure type which defines an event handler signalled to respond to user input messages in an application. It is used as a callback which forwards input messages from widget set classes to the current application.
          </p>
          <p>
            <var>TOnUserInputEvent</var> is the type used for the <var>OnUserInput</var> event handler in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnUserInput"/>
          <link id="TApplicationProperties.OnUserInput"/>
          <link id="TApplication.AddOnUserInputHandler"/>
          <link id="TApplication.RemoveOnUserInputHandler"/>
        </seealso>
      </element>
      <element name="TOnUserInputEvent.Sender">
        <short/>
      </element>
      <element name="TOnUserInputEvent.Msg">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDataEvent">
        <short>The type of an asynchronous callback method</short>
        <descr/>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TDataEvent.Data">
        <short>The argument passed to the method</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMHintShow">
        <short>Provides access to members in a CM_HINTSHOW control message</short>
        <descr>
          TCMHintShow is a record type used to represent a CM_HINTSHOW control message passed as an argument to control methods.
        </descr>
        <seealso>
          <link id="#lcl.controls.TControl.CMHintShow">TControl.CMHintShow</link>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Msg">
        <short>Cardinal value represnting the control message</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Reserved">
        <short>Reserved parameter values for the message</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.HintInfo">
        <short>Pointer to the hint information for the control message</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Result">
        <short>Result returned for the control message</short>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMHintShowPause">
        <short/>
        <descr>
          TCMHintShowPause is not used in the current LCL implementation.
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.WasActive">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Pause">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAppHintTimerType">
        <short>The TApplication hint timer state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAppHintTimerType.ahttNone">
        <short>The hint timer is off</short>
      </element>
      <element name="TAppHintTimerType.ahttShowHint">
        <short>Waiting to show a hint; used when a hint timer is started</short>
      </element>
      <element name="TAppHintTimerType.ahttHideHint">
        <short>Waiting to hide an hint; used when the hint control is changed or the mouse leaevs a hint rectangle</short>
      </element>
      <element name="TAppHintTimerType.ahttReshowHint">
        <short>Waiting to show the next hint; used when the hide hint timer is started</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TShowHintEvent">
        <short>Defines an event handler signalled to perform hint display</short>
        <descr>
          <p>
            <var>TShowHintEvent</var> is an object procedure type which defines an event handler signalled to perform hint display. It is the type used for the <var>TApplication.OnShowHint</var> event handler property.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnShowHint"/>
          <link id="TApplication.ShowHintWindow"/>
          <link id="TApplication.AddOnShowHintHandler"/>
          <link id="TApplication.RemoveOnShowHintHandler"/>
          <link id="TApplicationProperties.OnShowHint"/>
        </seealso>
      </element>
      <element name="TShowHintEvent.HintStr">
        <short/>
      </element>
      <element name="TShowHintEvent.CanShow">
        <short/>
      </element>
      <element name="TShowHintEvent.HintInfo">
        <short/>
      </element>
      <!-- record type Visibility: default -->
      <element name="THintInfoAtMouse">
        <short>
          Stores control and mouse position information for a hint display
        </short>
        <descr>
          <p>
            <var>THintInfoAtMouse</var> is a record type used to store Control and Mouse position information for a hint display.
          </p>
          <p>
            THintInfoAtMouse is passed as an argument to the <var>ShowHintWindow</var> method in <var>TApplication</var>. It is also used in the implementation of TApplication methods like <var>ActivateHint</var> and <var>OnHintTimer</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ShowHintWindow"/>
          <link id="TApplication.ActivateHint"/>
          <link id="TApplication.OnHintTimer"/>
        </seealso>
      </element>
      <element name="THintInfoAtMouse.MousePos">
        <short>POsition of the mouse cursor for the hint display</short>
      </element>
      <element name="THintInfoAtMouse.Control">
        <short>Control for the hint display</short>
      </element>
      <element name="THintInfoAtMouse.ControlHasHint">
        <short>Indicates if hint text is available for form or control</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationFlag">
        <short>Application state flags</short>
        <descr>
          <p>
            <var>TApplicationFlag</var> is an enumeration type with values that represent activity or state in an application. <var>TApplicationFlag</var> values are stored in the <var>TApplicationFlags</var> type used to implement the <var>Flags</var> property in <var>TApplication</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationFlags"/>
          <link id="TApplication.Flags"/>
        </seealso>
      </element>
      <element name="TApplicationFlag.AppWaiting">
        <short>Application is in an Idle state and waiting for a message</short>
      </element>
      <element name="TApplicationFlag.AppIdleEndSent">
        <short>
          IdleEnd handlers have been notified of message arrival; end the idle state for the application
        </short>
      </element>
      <element name="TApplicationFlag.AppHandlingException">
        <short>In exception handling</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <element name="TApplicationFlag.AppNoExceptionMessages">
        <short>
          Suppresses exception display for the application; set when an exception is aborted in the application
        </short>
      </element>
      <element name="TApplicationFlag.AppActive">
        <short>The application has focus; prevents recursive application activation</short>
      </element>
      <element name="TApplicationFlag.AppDestroying">
        <short>Shutting down; set when the application instance is freed</short>
      </element>
      <element name="TApplicationFlag.AppDoNotCallAsyncQueue">
        <short>Skip asynchronous callbacks between handled messages</short>
        <notes>
          <note>
            Included in Flags when the application is being destroyed. Causes an exception to be raised in QueueAsyncCall.
          </note>
        </notes>
      </element>
      <element name="TApplicationFlag.AppInitialized">
        <short>Application has been initialized</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TApplicationFlags" link="#lcl.forms.TApplicationFlag"/>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationNavigationOption">
        <short>Which keys can be used for the navigation within a form</short>
        <descr>
          <p>
            <var>TApplicationNavigationOption</var> is an enumerated type with values that control the behaviors enabled for navigation in an application. Values from TApplicationNavigationOption are stored in the <var>TApplicationNavigationOptions</var> set type used to implement the <var>Navigation</var> property in <var>TApplication</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationNavigationOptions"/>
          <link id="TApplication.Navigation"/>
        </seealso>
      </element>
      <element name="TApplicationNavigationOption.anoTabToSelectNext">
        <short>The Tab key moves the Focus to the next (or previous) control in TabOrder.
        </short>
      </element>
      <element name="TApplicationNavigationOption.anoReturnForDefaultControl">
        <short>The Enter key triggers the default action.
        </short>
      </element>
      <element name="TApplicationNavigationOption.anoEscapeForCancelControl">
        <short>The Escape key triggers the Cancel action</short>
      </element>
      <element name="TApplicationNavigationOption.anoF1ForHelp">
        <short>The F1 key brings up context sensitive help</short>
      </element>
      <element name="TApplicationNavigationOption.anoArrowToSelectNextInParent">
        <short>The Arrow keys move the focus</short>
        <notes><note>?</note></notes>
      </element>
      <!-- set type Visibility: default -->
      <element name="TApplicationNavigationOptions" link="#lcl.forms.TApplicationNavigationOption"/>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationHandlerType">
        <short>Types of Application notification handlers</short>
        <descr>
          TApplicationHandlerType is an enumerated type with values that identify handler categories used in TApplication.

          TApplicationHandlerType is used as an index value for the internal array of TMethodList instances used in TApplication. It is passed as an argument to the AddHandler and RemoveHandler methods in TApplication to identify the method list where the handler is stored. It is also used in the implementation of TApplication methods used to retrieve, execute, or maintain handlers such as: Destroy and RemoveAllHandlersOfObject.
        </descr>
        <seealso/>
      </element>
      <element name="TApplicationHandlerType.ahtIdle">
        <short>Application becoming idle</short>
      </element>
      <element name="TApplicationHandlerType.ahtIdleEnd">
        <short>Application idle state is ending</short>
      </element>
      <element name="TApplicationHandlerType.ahtKeyDownBefore">
        <short>Handler for KeyDown events, invoked before interface and LCL handlers</short>
      </element>
      <element name="TApplicationHandlerType.ahtKeyDownAfter">
        <short>
          Default handler for KeyDown events, invoked after interface and LCL handlers
        </short>
      </element>
      <element name="TApplicationHandlerType.ahtActivate">
        <short>Handler invoked on application activated</short>
      </element>
      <element name="TApplicationHandlerType.ahtDeactivate">
        <short>Handler invoked on application deactivated</short>
      </element>
      <element name="TApplicationHandlerType.ahtUserInput">
        <short>Handler invoked on user input</short>
        <notes>
          <note>Used in NotifyUserInputHandler; implemented in Sparta MDI package</note>
        </notes>
      </element>
      <element name="TApplicationHandlerType.ahtException">
        <short>Handler invoked on handled exception</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtEndSession">
        <short>Handler invoked on session end</short>
        <notes><note>Used in IntfEndSession.</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtQueryEndSession">
        <short>Handler invoked before session ends</short>
      </element>
      <element name="TApplicationHandlerType.ahtMinimize">
        <short>Handler invoked when the application is minimized</short>
      </element>
      <element name="TApplicationHandlerType.ahtModalBegin">
        <short>Handler invoked when a form is shown modally</short>
      </element>
      <element name="TApplicationHandlerType.ahtModalEnd">
        <short>Handler invoked when the last modal form is closed</short>
      </element>
      <element name="TApplicationHandlerType.ahtRestore">
        <short>Handler invoked on application restored (from minimized state)</short>
      </element>
      <element name="TApplicationHandlerType.ahtDropFiles">
        <short>Handler invoked on files dropped</short>
        <notes><note>Used in IntfDropFiles.</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtHelp">
        <short>Handler invoked on F1 key (help request)</short>
        <notes><note>Used when OnHelp is not assigned in the application.</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtHint">
        <short>Handler invoked on Hint request</short>
      </element>
      <element name="TApplicationHandlerType.ahtShowHint">
        <short>Handler invoked on Hint becoming visible</short>
      </element>
      <element name="TApplicationHandlerType.ahtGetMainFormHandle">
        <short>Handler provides the Handle for the main form</short>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PAsyncCallQueueItem" link="#lcl.forms.TAsyncCallQueueItem">
        <short>A queued asynchronous callback request node</short>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueueItem">
        <short>A queued asynchronous callback request node</short>
        <descr/>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueueItem.Method">
        <short>The callback method</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.Data">
        <short>The method call argument</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.NextItem">
        <short>The next list node</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.PrevItem">
        <short>The preceding list node</short>
        <descr>
        </descr>
        <notes><note>superfluous, could be removed?</note></notes>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueue">
        <short>The queue head for asynchronous callbacks</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueue.Top">
        <short>The first queued method</short>
      </element>
      <element name="TAsyncCallQueue.Last">
        <short>The last queued method</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueues">
        <short>Management information for asynchronous callbacks</short>
        <descr>
          <p>
            Two queues are used:
          </p>
          <p>
            New calls are added to the Next queue.
          </p>
          <p>
            When the application starts processing the calls, the Next queue becomes the Cur queue, and a new Next queue is created. This simplifies thread-safe addition in subsequent calls.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueues.CritSec">
        <short>The critical section for adding and removing queue elements</short>
        <descr>
        </descr>
      </element>
      <element name="TAsyncCallQueues.Cur">
        <short>The currently processed queue. Processed entries are removed</short>
        <descr>
        </descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TAsyncCallQueues.Next">
        <short>New calls are added to this queue</short>
        <descr>
        </descr>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationType">
        <short>
          Identifies the kind of device where the application currently runs
        </short>
        <descr>
          <p>
            <var>TApplicationType</var> identifies the kind of device where the application currently runs. Note that the same application can run on differing device types if it has a flexible user interface.
          </p>
          <p>
            TApplicationType is the type used to implement the <var>ApplicationType</var> property in <var>TApplication</var>, and returned from widgetset methods that identify the platform for the interface.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TApplicationType.atDefault">
        <short>The widgetset will attempt to auto-detect the device type</short>
      </element>
      <element name="TApplicationType.atDesktop">
        <short>For common desktops and notebooks</short>
      </element>
      <element name="TApplicationType.atPDA">
        <short>For smartphones and other devices with a smallish touchscreen</short>
      </element>
      <element name="TApplicationType.atKeyPadDevice">
        <short>Devices without any pointing device, such as keypad feature phones or kiosk machines</short>
      </element>
      <element name="TApplicationExceptionDlg">
        <short>Enumeration with dialog types for an application</short>
        <descr>
          <p>
            <var>TApplicationExceptionDlg</var> is an enumerated type with values that indicates the type of dialog displayed for an application exception. <var>TApplicationExceptionDlg</var> is the type used to implement the <var>ExceptionDialog</var> property in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ExceptionDialog"/>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <element name="TApplicationExceptionDlg.aedOkCancelDialog">
        <short>Exception handler window will be a dialog with Ok/Cancel buttons</short>
      </element>
      <element name="TApplicationExceptionDlg.aedOkMessageBox">
        <short>Exception handler window will be a simple message box</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationShowGlyphs">
        <short>Describes the policy for the application of how to show menu and button glyphs</short>
        <descr>
          <p>
            <var>TApplicationShowGlyphs</var> is an enuemrated type with values that indicate the policy for displaying glyphs on menus and buttons. TApplicationShowGlyphs is the type used to implement the <var>ShowButtonGlyphs</var> and <var>ShowMenuGlyphs</var> properties in both <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ShowButtonGlyphs"/>
          <link id="TApplication.ShowMenuGlyphs"/>
          <link id="TApplicationProperties.ShowButtonGlyphs"/>
          <link id="TApplicationProperties.ShowMenuGlyphs"/>
          <link id="#lcl.menus.TGlyphShowMode">TGlyphShowMode</link>
        </seealso>
      </element>
      <element name="TApplicationShowGlyphs.sbgAlways">
        <short>Show glyphs always (disregards system preferences)</short>
      </element>
      <element name="TApplicationShowGlyphs.sbgNever">
        <short>Show glyphs never (disregards system preferences)</short>
      </element>
      <element name="TApplicationShowGlyphs.sbgSystem">
        <short>Show glyphs according to the platform or OS preferences</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TTaskBarBehavior">
        <short>How forms are represented in the TaskBar</short>
        <descr>
          <p>
            <var>TTaskBarBehavior</var> is an enumerated type with values that define how forms are displayed in the task bar. TTaskBarBehavior is the type used to implement the <var>TaskBarBehavior</var> property in <var>TApplication</var>.
          </p>
          <remark>
            Please note: Some Linux window managers do not support task bar behaviors. For example: Cinnamon.
          </remark>
        </descr>
        <seealso>
          <link id="TApplication.TaskBarBehavior"/>
        </seealso>
      </element>
      <element name="TTaskBarBehavior.tbDefault">
        <short>Show TaskBar buttons according to the platform default</short>
      </element>
      <element name="TTaskBarBehavior.tbMultiButton">
        <short>Show buttons for Forms with ShowInTaskBar=stDefault</short>
      </element>
      <element name="TTaskBarBehavior.tbSingleButton">
        <short>Hide buttons for Forms with ShowInTaskBar=stDefault</short>
      </element>
      <element name="TApplicationDoubleBuffered">
        <short>
          Enumeration with values used in the DoubleBuffered property in TApplication
        </short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationDoubleBuffered.adbDefault">
        <short>
          Widget set dependent; for LCL/Win32 it is True,  unless in a remote desktop connection. For other widget sets it is False.
        </short>
      </element>
      <element name="TApplicationDoubleBuffered.adbFalse">
        <short/>
      </element>
      <element name="TApplicationDoubleBuffered.adbTrue">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TApplication">
        <short>Application management and configuration for a GUI application</short>
        <descr>
          <p>
            TApplication is a TCustomApplication descendant which provides facilities used  to manage and configure a GUI application. Properties, methods, and event handlers are provided which allow a program to create, execute, monitor, maintain and destroy an application and its forms. Every GUI application contains an Application variable that represents the TApplication or descendent class instance.
          </p>
          <p>
            TApplication provides a message processing loop that includes hooks for event handlers and exception handling, and supports dispatching messages for TCustomAction instances used in application forms. TApplication provides support for Hints and content-sensitive help for forms and controls used in the application. Convenience methods, like MessageBox, are provided to simplify access to dialogs and error messages in the application.
          </p>
        </descr>
        <notes>
          <note>
            Needs more (or better) descriptions.
          </note>
        </notes>
        <seealso>
          <link id="TScreen"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FApplicationHandlers">
        <short>Holds the registered notification handlers for the application</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FApplicationType" link="#lcl.forms.TApplication.ApplicationType"/>
      <!-- variable Visibility: private -->
      <element name="TApplication.FCaptureExceptions" link="#lcl.forms.TApplication.CaptureExceptions"/>
      <!-- variable Visibility: private -->
      <element name="TApplication.FComponentsToRelease">
        <short>The list of components marked for release</short>
        <descr/>
        <seealso>
          <link id="TApplication.Release"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FComponentsReleasing">
        <short>The list of components which currently are released (destroyed)</short>
        <descr/>
        <seealso>
          <link id="TApplication.Release"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FCreatingForm"/>
      <element name="TApplication.FDoubleBuffered"/>
      <element name="TApplication.FExceptionDialog"/>
      <element name="TApplication.FExtendedKeysSupport"/>
      <element name="TApplication.FFindGlobalComponentEnabled" link="#lcl.forms.TApplication.FindGlobalComponentEnabled"/>
      <element name="TApplication.FFlags" link="#lcl.forms.TApplication.Flags"/>
      <element name="TApplication.FHint" link="#lcl.forms.TApplication.Hint"/>
      <element name="TApplication.FHintColor" link="#lcl.forms.TApplication.HintColor"/>
      <element name="TApplication.FHintControl" link="#lcl.forms.TApplication.HintControl"/>
      <element name="TApplication.FHintHidePause" link="#lcl.forms.TApplication.HintHidePause"/>
      <element name="TApplication.FHintHidePausePerChar" link="#lcl.forms.TApplication.HintHidePausePerChar"/>
      <element name="TApplication.FHintPause" link="#lcl.forms.TApplication.HintPause"/>
      <element name="TApplication.FHintRect">
        <short>The screen area of the current Hint window</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FHintShortCuts" link="#lcl.forms.TApplication.HintShortCuts"/>
      <element name="TApplication.FHintShortPause" link="#lcl.forms.TApplication.HintShortPause"/>
      <element name="TApplication.FHintTimer">
        <short>The timer for showing and hiding Hints</short>
      </element>
      <element name="TApplication.FHintTimerType">
        <short>The Hint time mode</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FHintWindow">
        <short>The current Hint window</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FIcon" link="#lcl.forms.TApplication.Icon"/>
      <element name="TApplication.FBigIconHandle">
        <short>The Handle for the big application icon</short>
      </element>
      <element name="TApplication.FLayoutAdjustmentPolicy"/>
      <element name="TApplication.FMainFormOnTaskBar" link="#lcl.forms.TApplication.MainFormOnTaskBar"/>
      <element name="TApplication.FModalLevel" link="#lcl.forms.TApplication.ModalLevel"/>
      <element name="TApplication.FLayoutAdjustmentPolicy"/>
      <element name="TApplication.FMoveFormFocusToChildren"/>
      <element name="TApplication.FOnCircularException"/>
      <element name="TApplication.FOnGetMainFormHandle" link="#lcl.forms.TApplication.OnGetMainFormHandle"/>
      <element name="TApplication.FOnMessageDialogFinished"/>
      <element name="TApplication.FOnModalBegin" link="#lcl.forms.TApplication.OnModalBegin"/>
      <element name="TApplication.FOnModalEnd" link="#lcl.forms.TApplication.OnModalEnd"/>
      <element name="TApplication.FScaled"/>
      <element name="TApplication.FShowButtonGlyphs" link="#lcl.forms.TApplication.ShowButtonGlyphs"/>
      <element name="TApplication.FShowMenuGlyphs" link="#lcl.forms.TApplication.ShowMenuGlyphs"/>
      <element name="TApplication.FSmallIconHandle">
        <short>The Handle for the small application icon</short>
      </element>
      <element name="TApplication.FIdleLockCount">
        <short>Counter for nested Idle locks, preventing execution of OnIdle handlers</short>
      </element>
      <element name="TApplication.FLastKeyDownSender">
        <short>Cached key event parameter</short>
      </element>
      <element name="TApplication.FLastKeyDownKeys">
        <short>List of key values for the last KeyDown sender</short>
      </element>
      <element name="TApplication.FLastKeyDownShift">
        <short>Cached key event parameter</short>
      </element>
      <element name="TApplication.FMainForm" link="#lcl.forms.TApplication.MainForm"/>
      <element name="TApplication.FMouseControl" link="#lcl.forms.TApplication.MouseControl"/>
      <element name="TApplication.FNavigation" link="#lcl.forms.TApplication.Navigation"/>
      <element name="TApplication.FOldExceptProc">
        <short>The previously installed exception handler</short>
      </element>
      <element name="TApplication.FOnActionExecute" link="#lcl.forms.TApplication.OnActionExecute"/>
      <element name="TApplication.FOnActionUpdate" link="#lcl.forms.TApplication.OnActionUpdate"/>
      <element name="TApplication.FOnActivate" link="#lcl.forms.TApplication.OnActivate"/>
      <element name="TApplication.FOnDeactivate" link="#lcl.forms.TApplication.OnDeactivate"/>
      <element name="TApplication.FOnDestroy" link="#lcl.forms.TApplication.OnDestroy"/>
      <element name="TApplication.FOnDropFiles" link="#lcl.forms.TApplication.OnDropFiles"/>
      <element name="TApplication.FOnHelp" link="#lcl.forms.TApplication.OnHelp"/>
      <element name="TApplication.FOnHint" link="#lcl.forms.TApplication.OnHint"/>
      <element name="TApplication.FOnIdle" link="#lcl.forms.TApplication.OnIdle"/>
      <element name="TApplication.FOnIdleEnd" link="#lcl.forms.TApplication.OnIdleEnd"/>
      <element name="TApplication.FOnEndSession" link="#lcl.forms.TApplication.OnEndSession"/>
      <element name="TApplication.FOnQueryEndSession" link="#lcl.forms.TApplication.OnQueryEndSession"/>
      <element name="TApplication.FOnMinimize" link="#lcl.forms.TApplication.OnMinimize"/>
      <element name="TApplication.FOnRestore" link="#lcl.forms.TApplication.OnRestore"/>
      <element name="TApplication.FOnShortcut" link="#lcl.forms.TApplication.OnShortcut"/>
      <element name="TApplication.FOnShowHint" link="#lcl.forms.TApplication.OnShowHint"/>
      <element name="TApplication.FOnUserInput" link="#lcl.forms.TApplication.OnUserInput"/>
      <element name="TApplication.FAsyncCall" link="#lcl.forms.TApplication.QueueAsyncCall">
        <short>Queues for asynchronous calls</short>
      </element>
      <element name="TApplication.FShowHint" link="#lcl.forms.TApplication.ShowHint"/>
      <element name="TApplication.FShowMainForm" link="#lcl.forms.TApplication.ShowMainForm"/>
      <element name="TApplication.FLastMousePos">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FLastMouseControl">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FLastMouseControlValid">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FBidiMode" link="#lcl.forms.TApplication.BiDiMode"/>
      <element name="TApplication.FRestoreStayOnTop">
        <short>The list of all forms that should be restored to StayOnTop</short>
        <descr>The list is created in RemoveStayOnTop, processed in RestoreStayOnTop.</descr>
      </element>
      <element name="TApplication.FTaskBarBehavior" link="#lcl.forms.TApplication.TaskBarBehavior"/>
      <element name="TApplication.FUpdateFormatSettings"/>
      <element name="TApplication.FRemoveStayOnTopCounter"/>
      <element name="TApplication.FExceptionCounter"/>
      <element name="TApplication.DoOnIdleEnd">
        <short>Notifies the OnIdleEnd handlers; called when the application exits Idle state</short>
      </element>
      <element name="TApplication.GetActive" link="#lcl.forms.TApplication.Active"/>
      <element name="TApplication.GetActive.Result">
        <short/>
      </element>
      <element name="TApplication.GetCurrentHelpFile">
        <short>Gets the HelpFile name for the active form, or the Application</short>
        <descr>
          <p>
            <var>GetCurrentHelpFile</var> is a <var>String</var> function used to get the help file name for the active form or application.
          </p>
          <p>
            <var>GetCurrentHelpFile</var> checks for an active form in the <var>Screen</var>  singleton. If a form is active, the file name in its <var>HelpFile</var> property is used as the return value. If a form is not active, the <var>HelpFile</var> in the <var>Application</var> instance is used.
          </p>
        </descr>
        <seealso>
          <link id="TScreen.ActiveCustomForm"/>
          <link id="TCustomForm.HelpFile"/>
          <link id="TApplication.HelpFile"/>
        </seealso>
      </element>
      <element name="TApplication.GetCurrentHelpFile.Result">
        <short>Help file name located in the method</short>
      </element>
      <element name="TApplication.GetExename">
        <short>Gets the name of the executable for the application</short>
        <descr>
          <p>
            <var>GetExename</var> is a <var>String</var> function used to get the name of the executable file which started the application. The return value contains the first commandline parameter (ordinal position 0) returned from the <var>ParamStrUTF8</var> routine in <file>LazUtils</file>.
          </p>
        </descr>
        <seealso>
          <link id="LazUtils.LazUTF8.ParamStrUTF8"/>
        </seealso>
      </element>
      <element name="TApplication.GetExename.Result">
        <short>Name of the executable file used to start the application</short>
      </element>
      <element name="TApplication.GetHandle">
        <short>Gets the value for the Handle property</short>
        <descr>
          Returns the AppHandle property from the WidgetSet singleton.
        </descr>
        <seealso>
          <link id="TApplication.Handle"/>
        </seealso>
      </element>
      <element name="TApplication.GetHandle.Result">
        <short>The Handle for the application</short>
      </element>
      <element name="TApplication.GetMainFormHandle">
        <short>Determines the main form handle, using all available handlers</short>
        <seealso>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.GetMainFormHandle.Result">
        <short/>
      </element>
      <element name="TApplication.GetTitle">
        <short>
          When no Title was stored, extracts the program name from the commandline arguments
        </short>
        <descr/>
      </element>
      <element name="TApplication.GetTitle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.FreeIconHandles">
        <short>Destroys the application icons</short>
        <descr>
          <p>
            <var>FreeIconHandles</var> is a procedure used to free icon handles used in the application. FreeIconHandles ensures that the internal members for the small and large icon handles are destroyed (when assigned). The <var>DestroyIcon</var> routine is called to destroy each of the icon handles using the correct routine for the widget set implementation.
          </p>
          <p>
            FreeIconHandles is called from the destructor for the class instance, and when an icon for the application has been changed.
          </p>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="TApplication.Destroy"/>
          <link id="TApplication.IconChanged"/>
          <link id="TApplication.SmallIconHandle"/>
          <link id="TApplication.BigIconHandle"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.IconChanged">
        <short>Loads the new application icons, notifies the widget set and all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IconChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetBidiMode" link="#lcl.forms.TApplication.BiDiMode"/>
      <element name="TApplication.SetBidiMode.AValue">
      <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetFlags" link="#lcl.forms.TApplication.Flags"/>
      <element name="TApplication.SetFlags.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetMainFormOnTaskBar" link="#lcl.forms.TApplication.MainFormOnTaskBar"/>
      <element name="TApplication.SetMainFormOnTaskBar.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetNavigation" link="#lcl.forms.TApplication.Navigation"/>
      <element name="TApplication.SetNavigation.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowButtonGlyphs" link="#lcl.forms.TApplication.ShowButtonGlyphs"/>
      <element name="TApplication.SetShowButtonGlyphs.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowMenuGlyphs" link="#lcl.forms.TApplication.ShowMenuGlyphs"/>
      <element name="TApplication.SetShowMenuGlyphs.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetTaskBarBehavior" link="#lcl.forms.TApplication.TaskBarBehavior"/>
      <element name="TApplication.SetTaskBarBehavior.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.UpdateMouseControl">
        <short>Handles mouse moving onto a new control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.UpdateMouseControl.NewMouseControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.UpdateMouseHint">
        <short>Sets Hint to the (new) hint that applies to CurrentControl</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.UpdateMouseHint.CurrentControl">
        <short>The control under the mouse</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetCaptureExceptions" link="#lcl.forms.TApplication.CaptureExceptions"/>
      <element name="TApplication.SetCaptureExceptions.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetHint" link="#lcl.forms.TApplication.Hint"/>
      <element name="TApplication.SetHint.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetHintColor" link="#lcl.forms.TApplication.HintControl"/>
      <element name="TApplication.SetHintColor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetIcon" link="#lcl.forms.TApplication.Icon"/>
      <element name="TApplication.SetIcon.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowHint" link="#lcl.forms.TApplication.ShowHint"/>
      <element name="TApplication.SetShowHint.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.StopHintTimer">
        <short>Disables the Hint timer</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.ValidateHelpSystem">
        <short>
          Checks for an installed <link id="#lcl.HelpIntfs.HelpManager">HelpManager</link>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ValidateHelpSystem.Result">
        <short>True when HelpManager is not Nil</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.WndProc" link="#lcl.controls.TControl.WndProc"/>
      <element name="TApplication.WndProc.AMessage">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.DispatchAction">
        <short>Asks the active form and MainForm to handle the action</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TApplication.DispatchAction.Result">
        <short>True when the action was handled</short>
      </element>
      <element name="TApplication.DispatchAction.Msg">
        <short/>
      </element>
      <element name="TApplication.DispatchAction.Action">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.AddHandler">
        <short>Adds an application notification handler</short>
        <descr/>
        <seealso>

        </seealso>
      </element>
      <element name="TApplication.AddHandler.HandlerType">
        <short/>
      </element>
      <element name="TApplication.AddHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.RemoveHandler">
        <short>Removes an application notification handler</short>
        <descr/>
        <seealso>

        </seealso>
      </element>
      <element name="TApplication.RemoveHandler.HandlerType">
        <short/>
      </element>
      <element name="TApplication.RemoveHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.RunLoop">
        <short>Encapsulates the application message loop (HandleMessage)</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.Activate">
        <short>Handler for application activation, notifies all activation handlers</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.Deactivate">
        <short>Handler for application deactivation, notifies all deactivation handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Deactivate.Force">
        <short>True when called from the widget set</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.GetConsoleApplication">
        <short>Here: returns False, because this is a GUI application.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.GetConsoleApplication.Result">
        <short>False for a GUI application</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyIdleHandler">
        <short>Notifies all Idle handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnIdle"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyIdleHandler.Done">
        <short>True when all handlers are done, meaning: wait for next message</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyIdleEndHandler">
        <short>Notifies all Idle End handlers, when a new message arrived</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnIdleEnd"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyActivateHandler">
        <short>Notifies all Activation handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnActivate"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyDeactivateHandler">
        <short>Notifies all Deactivation handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyCustomForms">
        <short>Notifies all CustomForms of Msg arrived</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.NotifyCustomForms.Msg">
        <short>The message to process</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.IsHintMsg">
        <short>NOP, exists for Delphi compatibility only</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsHintMsg.Result">
        <short>Always False</short>
      </element>
      <element name="TApplication.IsHintMsg.Msg">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.DoOnHelp">
        <short>
          OnHelp message handler. Tries the OnHelp handlers for the active form, and the Application,  as well as application Help handlers.
        </short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.OnHelp"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.DoOnHelp.Result">
        <short>True when the message was handled</short>
      </element>
      <element name="TApplication.DoOnHelp.Command">
        <short/>
      </element>
      <element name="TApplication.DoOnHelp.Data">
        <short/>
      </element>
      <element name="TApplication.DoOnHelp.CallHelp">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoOnMouseMove">
        <short>OnMouseMove message handler, updates the Hint</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ShowHintWindow">
        <short>Shows or hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowHintWindow.Info">
        <short>Is updated with the Hint related information</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.OnHintTimer">
        <short>Event handler for timing the duration of hints</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.OnHintTimer.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.SetTitle" link="#lcl.forms.TApplication.Title"/>
      <element name="TApplication.SetTitle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.StartHintTimer">
        <short>Starts the timer for display of a hint message</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.StartHintTimer.Interval">
        <short/>
      </element>
      <element name="TApplication.StartHintTimer.TimerType">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.UpdateVisible">
        <short>Asks the widget set to update the TaskBar entries</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoIdleActions">
        <short>Updates all Actions, hides splash screens</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.MenuPopupHandler">
        <short>Hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.MenuPopupHandler.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ProcessAsyncCallQueue">
        <short>Calls all methods queued by QueueAsyncCall</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.FreeComponent" link="#lcl.forms.TApplication.ReleaseComponents"/>
      <element name="TApplication.FreeComponent.Data">
        <short>Ignored, should be zero</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ReleaseComponents">
        <short>Destroys all components marked for release</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoBeforeFinalization">
        <short>Destroys all components</short>
        <descr>
          <p>
            Called from the <var>BeforeFinalization</var> routine which is used as the <var>ExitProc</var> handler in the application instance.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.GetParams">
        <short>Returns the commandline argument at the specified position</short>
      </element>
      <element name="TApplication.GetParams.Result">
        <short/>
      </element>
      <element name="TApplication.GetParams.Index">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TApplication.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TApplication.Create.AOwner">
        <short>The Owner object that invoked this instance of TApplication</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TApplication.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance.
          </p>
          <p>
            <var>Destroy</var> ensures that the value <var>AppDestroying</var> is included in the <var>Flags</var> for the application, and signals the <var>OnDestroy</var> event handler (when assigned). Destroy calls the <var>ProcessAsyncCallQueue</var> method to process / handle queued asynchronous method calls pending for the application instance.
          </p>
          <p>
            Hint display is cancelled and suppressed while the application is shutting down. The action component for the application is set to <b>Nil</b> to prevent execution of associated actions during shutdown.
          </p>
          <p>
            Destroy frees resources allocated in the application instance, including the Icon and any Icon handles currently in use.  Handlers added to application instance are also freed.
          </p>
          <p>
            Destroy calls the inherited destructor, and discards any pending asynchronous calls not previously handled for the application instance. Exception handling is restored to the state on entry to the Create constructor. Finally, the Application class instance is set to <b>Nil</b>.
          </p>
        </descr>
        <errors>
          Destroy calls <var>RaiseGDBException</var> to raise an exception if the current class instance is unassigned (contains <b>Nil</b>). Uses the exception message 'TApplication.Destroy Self=nil'.
        </errors>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ActivateHint">
        <short>Configures a hint window for the specified mouse position</short>
        <descr>
          <p>
            <var>ActivateHint</var> is a procedure used to configure a hint window display at the coordinates specified in <var>CursorPos</var>.
          </p>
          <p>
            ActivateHint retrieves the hint information at the mouse position. If the control for the hint differs from the current hint control, the existing hint is deactivated. The new hint window sets its hint timer and calculates the rectangle for the hint window.
          </p>
          <p>
            If a hint is not availabe for the specified mouse position, the <var>CancelHint</var> method is called.
          </p>
          <p>
            ActivateHint is used in the implementation of the <var>DoOnMouseMove</var> and <var>ShowHintWindow</var> methods.
          </p>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="TApplication.ShowHintWindow"/>
          <link id="TApplication.DoOnMouseMove"/>
          <link id="TApplication.CancelHint"/>
          <link id="TApplication.HideHint"/>
          <link id="TApplication.Hint"/>
          <link id="TApplication.HintPause"/>
          <link id="TApplication.OnHint"/>
        </seealso>
      </element>
      <element name="TApplication.ActivateHint.CursorPos">
        <short>Mouse cursor position used to retrieve the hint information</short>
      </element>
      <element name="TApplication.ActivateHint.CheckHintControlChange">
        <short>Indicates if hint controls are used to compared existing and new hint windows</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.GetControlAtMouse">
        <short>Finds the control under the mouse</short>
        <descr>Updates the LastMouse... info.</descr>
        <seealso/>
      </element>
      <element name="TApplication.GetControlAtMouse.Result">
        <short>The control, or Nil if no control is found</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlDestroyed">
        <short>Clears all references to the destroyed control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlDestroyed.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.BigIconHandle">
        <short>The Handle of the large application Icon</short>
        <seealso>
          <link id="TApplication.Icon"/>
        </seealso>
      </element>
      <element name="TApplication.BigIconHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.SmallIconHandle">
        <short>The Handle of the small application Icon</short>
        <seealso>
          <link id="TApplication.Icon"/>
        </seealso>
      </element>
      <element name="TApplication.SmallIconHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.BringToFront">
        <short>Asks the widget set to bring the application's form(s) to the front
        </short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.CreateForm">
        <short>Creates a Form or component, owned by Application</short>
        <descr>
          <remark>
            Please note: The method name is confusing and kept only for Delphi compatibility. The method can actually create any kind of component.
          </remark>
          <p>
            CreateForm creates a Component instance of the given class, and sets the pointer to the component variable. If it is a form, it will be added to the form list in the application.
          </p>
          <p>
            A splash form is shown immediately.
          </p>
        </descr>
        <seealso/>
        <notes>
          <note>and loads the component?</note>
        </notes>
      </element>
      <element name="TApplication.CreateForm.InstanceClass">
        <short>The component class</short>
      </element>
      <element name="TApplication.CreateForm.Reference">
        <short>The variable receiving the new component reference</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.UpdateMainForm">
        <short>
          When MainForm is Nil, this form becomes the application MainForm
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.UpdateMainForm.AForm">
        <short>The form that may become the MainForm</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.QueueAsyncCall">
        <short>Inserts an asynchronous call into the queue</short>
        <descr>This is thread safe.</descr>
        <errors>Exceptions on various inconsistencies of the queue.
        </errors>
        <seealso/>
        <example file="forms/tapplication_queueasynccall.pas"/>
      </element>
      <element name="TApplication.QueueAsyncCall.AMethod">
        <short>The method to call asynchronously</short>
      </element>
      <element name="TApplication.QueueAsyncCall.Data">
        <short>The argument passed to the method</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveAsyncCalls">
        <short>Removes all calls added via QueueAsyncCall</short>
        <descr>This is thread safe.</descr>
        <errors>Exceptions on various inconsistencies of the queue.</errors>
      </element>
      <element name="TApplication.RemoveAsyncCalls.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ReleaseComponent">
        <short>Safe destruction of a component, can be requested
          by the component itself</short>
        <descr>
          <p>
            Unless the application is shutting down, all requests are queued. Queued requests are processed when the application is not currently processing a message.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TApplication.ReleaseComponent.AComponent">
        <short>The component to destroy</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.ExecuteAction">
        <short>Invokes the <var>OnActionExecute</var> handler</short>
        <seealso>
          <link id="#rtl.classes.TComponent.ExecuteAction">TComponent.ExecuteAction</link>
        </seealso>
      </element>
      <element name="TApplication.ExecuteAction.Result">
        <short>True when the Action was handled</short>
      </element>
      <element name="TApplication.ExecuteAction.ExeAction">
        <short>The Action to execute</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.UpdateAction">
        <short>Invokes the <var>OnActionUpdate</var> handler</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.UpdateAction">TComponent.UpdateAction</link>
        </seealso>
      </element>
      <element name="TApplication.UpdateAction.Result">
        <short/>
      </element>
      <element name="TApplication.UpdateAction.TheAction">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HandleException">
        <short>
          <var>HandleException</var> method for handling an exception;
          attempts to maintain program execution if possible, otherwise exits gracefully
        </short>
        <descr>
          <p>
            Individual exception handler methods should be supplied by the application programmer, to override place-holder entries declared in ancestor classes. This method checks whether the application is halted when an exception occurs, or invokes the appropriate handler. It also writes details about the exception to the appropriate place for debugging.
          </p>
        </descr>
        <seealso>
          <link id="#fcl.custapp.TCustomApplication.HandleException">TCustomApplication.HandleException</link>
        </seealso>
      </element>
      <element name="TApplication.HandleException.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HandleMessage">
        <short>Handles all messages, and enters the Idle state</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpCommand">
        <short>Show help</short>
        <descr>Currently relies on OnHelp handlers. CallHelp is not implemented.</descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.HelpCommand.Result">
        <short/>
      </element>
      <element name="TApplication.HelpCommand.Command">
        <short/>
      </element>
      <element name="TApplication.HelpCommand.Data">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpContext">
        <short>Show context sensitive help</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.HelpContext.Result">
        <short>Request handled</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.HelpContext.Context">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpKeyword">
        <short>Show help for a keyword</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.HelpKeyword.Result">
        <short/>
      </element>
      <element name="TApplication.HelpKeyword.Keyword">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ShowHelpForObject">
        <short>When Sender is a TControl, invoke its ShowHelp method</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowHelpForObject.Sender">
        <short>Should be a TControl, else nothing will happen</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveStayOnTop">
        <short>
          Remove StayOnTop from all forms. Builds a form list for use in RestoreStayOnTop.
        </short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RestoreStayOnTop"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveStayOnTop.ASystemTopAlso">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RestoreStayOnTop">
        <short>Restores StayOnTop for all forms changed by RemoveStayOnTop</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RemoveStayOnTop"/>
        </seealso>
      </element>
      <element name="TApplication.RestoreStayOnTop.ASystemTopAlso">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsWaiting">
        <short>True if the application is awaiting an event</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.IsWaiting.Result">
        <short>True if the application is in AppWaiting state</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.CancelHint">
        <short>Called when the Hint time has expired, to stop showing the Hint.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HideHint">
        <short>Hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HintMouseMessage">
        <short>Called when the the mouse is over a control with a Hint</short>
        <descr>Does nothing</descr>
        <seealso/>
        <notes>
          <note>?</note><note>exists for Delphi compatibility only?</note>
        </notes>
      </element>
      <element name="TApplication.HintMouseMessage.Control">
        <short/>
      </element>
      <element name="TApplication.HintMouseMessage.AMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Initialize">
        <short>Initializes the widget set (and more)</short>
        <descr>
          <p>
            <var>Initialize</var> is an overridden procedure in TApplication used to perform initialization tasks for the application. Initialize calls the inherited method to provide supprt for instance counting in the custom application. Initialize ensures that the <var>WidgetSet</var> class type is assigned for the application, and that the Screen singleton is initialized and updated.
          </p>
          <p>
            Initialize raises an <var>Exception</var> if WidgetSet has not been assigned, or contains a class type other than <var>TWidgetSet</var>, for the application.
          </p>
          <p>
            Initialize updates the <var>Flags</var> property to include the value <b>AppInitialized</b> when both the LCL interface (Widget set) and the Screen singleton have been configured.
          </p>
          <p>
            Initialize loads the graphic image used in the <var>Icon</var> property. If a resource with the name <b>MAINICON</b> is included in the Lazarus Resource, it is loaded and used as the application icon. Otherwise, <var>FindResource</var> is called to locate and load the named icon from the resource handle.
          </p>
        </descr>
        <errors>
          Raises an Exception if the Widget Set class is invalid or not assigned.
        </errors>
        <seealso>
          <link id="Screen"/>
          <link id="TApplication.Icon"/>
          <link id="TApplication.Flags"/>
          <link id="#lcl.interfacebase.WidgetSet">WidgetSet</link>
          <link id="#fcl.custapp.TCustomApplication.Initialize">TCustomApplication.Initialize</link>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.MessageBox">
        <short>Display an message dialog with several response buttons</short>
        <descr>
          <p>
            The function is used internally to display messages during the handling of <var>Exceptions</var>, but is also available to application programmers as an alternative to some of the message dialogs found in the <file>Dialogs</file> unit.
          </p>
          <p>
            The function returns an integer value corresponding to the button that was pressed; its value can be determined by reference to the constants [IDOK..IDHELP].
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Dialogs.MessageDlg">MessageDlg</link>
        </seealso>
        <example file="dialogs/displaymessagebox.pas"/>
      </element>
      <element name="TApplication.MessageBox.Result">
        <short>Indicates the pressed button</short>
        <descr>
          <p>Can be one of the following values:</p>
          <ul>
            <li>IDOK</li>
            <li>IDCANCEL</li>
            <li>IDABORT</li>
            <li>IDRETRY</li>
            <li>IDIGNORE</li>
            <li>IDYES</li>
            <li>IDNO</li>
            <li>IDCLOSE</li>
            <li>IDHELP</li>
          </ul>
        </descr>
      </element>
      <element name="TApplication.MessageBox.Text">
        <short>The text in the MessageBox</short>
        <descr/>
      </element>
      <element name="TApplication.MessageBox.Caption">
        <short>The Caption of the MessageBox</short>
        <descr/>
      </element>
      <element name="TApplication.MessageBox.Flags">
        <short>The icon and buttons appearing in the box.
        </short>
        <descr>
          <p>
            Several constants are declared in the LCLType unit.
          </p>
          <p>Add (better: OR) an icon constant and a buttons constant. For example:</p>
          <code>MB_ABORTRETRYIGNORE + MB_ICONQUESTION</code>
          <p>Causes the application to display a query (?) icon in a box with three buttons: ABORT RETRY IGNORE.</p>
          <p>Buttons can be one of:</p>
          <ul>
            <li>MB_OK</li>
            <li>MB_OKCANCEL</li>
            <li>MB_ABORTRETRYIGNORE</li>
            <li>MB_YESNOCANCEL</li>
            <li>MB_YESNO</li>
            <li>MB_RETRYCANCEL</li>
          </ul>
          <p>The icon can be one of:</p>
          <ul>
            <li>MB_ICONHAND</li>
            <li>MB_ICONQUESTION</li>
            <li>MB_ICONEXCLAMATION</li>
            <li>MB_ICONASTERISK</li>
            <li>MB_ICONWARNING = MB_ICONEXCLAMATION</li>
            <li>MB_ICONERROR = MB_ICONHAND</li>
            <li>MB_ICONSTOP = MB_ICONHAND</li>
            <li>MB_ICONINFORMATION = MB_ICONASTERISK</li>
          </ul>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Minimize">
        <short>Asks the widget set to minimize the application.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ModalStarted">
        <short>Called when a form is shown modally</short>
        <descr>Invokes all OnModalBegin handlers when entering Modal state.
        </descr>
        <seealso>
          <link id="TApplication.ModalFinished"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ModalFinished">
        <short>Called when a modal form is closed</short>
        <descr>Invokes all OnModalEnd handlers when exiting Modal state.
        </descr>
        <seealso>
          <link id="TApplication.ModalStarted"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Restore">
        <short>Restores the previously minimized application.
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.Minimize"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Notification">
        <short>Invokes the notification handlers.
        </short>
        <descr>
          <p>
            Special handling, here: Clears the reference to a removed component, terminates the application when the MainForm is removed.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification">TComponent.Notification</link>
        </seealso>
      </element>
      <element name="TApplication.Notification.AComponent">
        <short/>
      </element>
      <element name="TApplication.Notification.Operation">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ProcessMessages">
        <short>
          Call this method during lengthy operations, to keep the GUI responsive
        </short>
        <descr>
          Processes all waiting messages, then the queued asynchronous callbacks.
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Idle">
        <short>Invoked when the application enters the idle state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Idle.Wait">
        <short>Wait for next message?</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Run" link="#fcl.CustApp.TCustomApplication.Run">
        <short>MainForm is loaded and control is passed to the event loop</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RunLoop"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ShowException" link="#fcl.CustApp.TCustomApplication.ShowException">
        <short>Shows the exception message and asks the user to abort or continue</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowException.E">
        <short>The exception to display for the application</short>
        <seealso>
          <link id="#rtl.sysutils.Exception">Exception</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Terminate" link="#fcl.CustApp.TCustomApplication.Terminate">
        <short>The application is terminated and the component engine is shutdown</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DisableIdleHandler">
        <short>
          Blocks Idle handling. Can be called more often, every call must be followed by EnableIdleHandler.
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.EnableIdleHandler"/>
        </seealso>
        <notes><note>what does this mean to application behavior?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.EnableIdleHandler">
        <short>Resume Idle handling</short>
        <descr/>
        <errors>GDB exception when not previously disabled.</errors>
        <seealso>
          <link id="TApplication.DisableIdleHandler"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyUserInputHandler">
        <short>Notifies all user input handlers</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>of what?</note></notes>
      </element>
      <element name="TApplication.NotifyUserInputHandler.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyKeyDownBeforeHandler">
        <short>Notifies all ahtKeyDownBefore handlers</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Sender">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Key">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyKeyDownHandler">
        <short>Notifies all ahtKeyDownAfter handlers, eventually reacts on F1 (Help)</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Sender">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Key">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlKeyDown">
        <short>Handles KeyDown events in a Control, e.g. handles navigation keys</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlKeyDown.Sender">
        <short/>
      </element>
      <element name="TApplication.ControlKeyDown.Key">
        <short/>
      </element>
      <element name="TApplication.ControlKeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlKeyUp">
        <short>Handles KeyUp events in a Control, e.g. handles Enter and Esc keys</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlKeyUp.Sender">
        <short/>
      </element>
      <element name="TApplication.ControlKeyUp.Key">
        <short/>
      </element>
      <element name="TApplication.ControlKeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnIdleHandler">
        <short>Adds an application Idle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnIdleHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnIdleHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnIdleHandler">
        <short>Removes an application Idle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnIdleHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnIdleEndHandler">
        <short>Adds an application IdleEnd handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnIdleEndHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnIdleEndHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnIdleEndHandler">
        <short>Removes an application IdleEnd handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnIdleEndHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnUserInputHandler">
        <short>Adds an application user input handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnUserInputHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnUserInputHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnUserInputHandler">
        <short>Removes an application user input handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnUserInputHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnKeyDownBeforeHandler">
        <short>Adds an application key down before interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnKeyDownBeforeHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnKeyDownBeforeHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnKeyDownBeforeHandler">
        <short>Removes an application key down before interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnKeyDownBeforeHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnKeyDownHandler">
        <short>Adds an application key down after interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnKeyDownHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnKeyDownHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnKeyDownHandler">
        <short>Removes an application key down after interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnKeyDownHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnActivateHandler">
        <short>Adds an application activation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnActivateHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnActivateHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnActivateHandler">
        <short>Removes an application activation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnActivateHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnDeactivateHandler">
        <short>Adds an application deactivation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnDeactivateHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnDeactivateHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnDeactivateHandler">
        <short>Removes an application deactivation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnDeactivateHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnExceptionHandler">
        <short>Adds an application exception handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnExceptionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnExceptionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnExceptionHandler">
        <short>Removes an application exception handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnExceptionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnEndSessionHandler">
        <short>Adds an application logoff handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.AddOnEndSessionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnEndSessionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnEndSessionHandler">
        <short>Removes an application logoff handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.RemoveOnEndSessionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnQueryEndSessionHandler">
        <short>Adds an application logoff query handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnQueryEndSessionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnQueryEndSessionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnQueryEndSessionHandler">
        <short>Removes an application logoff query handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnQueryEndSessionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnMinimizeHandler">
        <short>Adds an application minimizing handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnMinimizeHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnMinimizeHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnMinimizeHandler">
        <short>Removes an application minimizing handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnMinimizeHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnModalBeginHandler">
        <short>Adds an application becoming modal handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnModalBeginHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnModalBeginHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnModalBeginHandler">
        <short>Removes an application becoming modal handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnModalBeginHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnModalEndHandler">
        <short>Adds an application exiting modal state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnModalEndHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnModalEndHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnModalEndHandler">
        <short>Removes an application exiting modal state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnModalEndHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnRestoreHandler">
        <short>Adds an application exiting minimized state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnRestoreHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnRestoreHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnRestoreHandler">
        <short>Removes an application exiting minimized state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnRestoreHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnDropFilesHandler">
        <short>Adds an application dropped files handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnDropFilesHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnDropFilesHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnDropFilesHandler">
        <short>Removes an application dropped files handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnDropFilesHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnHelpHandler">
        <short>Adds an application Help handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnHelpHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnHelpHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnHelpHandler">
        <short>Removes an application Help handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnHelpHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnHintHandler">
        <short>Adds an application Hint handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnHintHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnHintHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnHintHandler">
        <short>Removes an application Hint handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnHintHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnShowHintHandler">
        <short>Adds an application Hint show handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnShowHintHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnShowHintHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnShowHintHandler">
        <short>Removes an application Hint show handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnShowHintHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnGetMainFormHandleHandler">
        <short>Adds an application MainForm Handle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnGetMainFormHandleHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnGetMainFormHandleHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnGetMainFormHandleHandler">
        <short>Removes an application MainForm Handle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnGetMainFormHandleHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveAllHandlersOfObject">
        <short>Removes all handlers implemented in the given object</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoBeforeMouseMessage">
        <short>Things to be done before a mouse message is processed</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoBeforeMouseMessage.CurMouseControl">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsShortcut">
        <short>Asks all shortcut handlers to handle the key</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsShortcut.Result">
        <short>True when the shortcut was handled</short>
      </element>
      <element name="TApplication.IsShortcut.Message">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfQueryEndSession">
        <short>Called by the interface to confirm the end of a session</short>
        <descr>Asks all QueryEndSession handlers to confirm termination of the application.
        </descr>
        <seealso>
          <link id="TApplication.OnQueryEndSession"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.IntfQueryEndSession.Cancel">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfEndSession">
        <short>Called by the interface when the session ends</short>
        <descr>Notifies all OnEndSession handlers.</descr>
        <seealso>
          <link id="TApplication.OnEndSession"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppActivate">
        <short>Called by the interface on application activation</short>
        <descr>Notifies all activation handlers.</descr>
        <seealso>
          <link id="TApplication.OnActivate"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppDeactivate">
        <short>Called by the interface on application deactivation</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppMinimize">
        <short>Called by the interface when the application is minimized</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnMinimize"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppRestore">
        <short>Called by the interface when the application is restored</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnRestore"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfDropFiles">
        <short>Called by the interface when files have been dropped</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDropFiles"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.IntfDropFiles.FileNames">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfThemeOptionChange">
        <short>Called by the interface when a theme option has changed</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IntfThemeOptionChange.AThemeServices">
        <short/>
      </element>
      <element name="TApplication.IntfThemeOptionChange.AOption">
        <short/>
      </element>
      <element name="TApplication.IsRightToLeft">
        <short>Indicates if BiDiMode contains a value other than bdLeftToRight</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsRightToLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsRTLLang">
        <short>Checks the given language name for use of right-to-left reading</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsRTLLang.Result">
        <short>True when the language code uses right-to-left reading</short>
      </element>
      <element name="TApplication.IsRTLLang.ALang">
        <short>ISO language code examined in the method</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.Direction">
        <short>Gets the BidiMode value for the specified language name</short>
        <descr/>
        <errors></errors>
        <seealso/>
      </element>
      <element name="TApplication.Direction.Result">
        <short>TBiDiMode value for the specified language</short>
      </element>
      <element name="TApplication.Direction.ALang">
        <short>ISO language name examined in the method</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.DoArrowKey">
        <short>Uses arrow keys for navigation, if enabled</short>
      </element>
      <element name="TApplication.DoArrowKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoArrowKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoArrowKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoTabKey">
        <short>Uses the Tab key for navigation, if enabled</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoTabKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoTabKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoTabKey.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoEscapeKey">
        <short>Interprets Esc as Cancel action, if applicable</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoEscapeKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoEscapeKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoEscapeKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoReturnKey">
        <short>Interprets Enter as the default action, if applicable</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoReturnKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoReturnKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoReturnKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Active">
        <short>True if the application has the focus</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ApplicationType">
        <short>
          The type of the application (i.e. the sort of device for which it is intended)
        </short>
        <descr>
          <p>The type of the application:</p>
          <p>Default, Desktop, Handheld, PDA, Smartphone</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.BidiMode">
        <short>The bidirectional mode to use</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.CaptureExceptions">
        <short>Enables exception handling by Application</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoubleBuffered">
        <short>Indicates if the application uses double buffering</short>
        <descr>Default value is adbDefault. Hint: platform specific.</descr>
        <seealso/>
      </element>
      <element name="TApplication.ExtendedKeysSupport">
        <short/>
        <descr>See VK_LSHIFT in LCLType for more details.</descr>
        <seealso/>
      </element>
      <element name="TApplication.ExceptionDialog">
        <short>Indicates the dialog type used for an exception in the application</short>
        <descr>
          <p>
            <var>ExceptionDialog</var> is a <var>TApplicationExceptionDlg</var> property which indicates the dialog type displayed for an exception handled by the application instance. The default value for the property is <var>aedOkCancelDialog</var>, as assigned in the <var>Create</var> constructor.
          </p>
          <p>
            See TApplicationExceptionDlg for more information about values in the enumeration and their meanings.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationExceptionDlg"/>
          <link id="TApplication.Create"/>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.FindGlobalComponentEnabled">
        <short>Enables searching for global components by name</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Flags">
        <short>Application state flags</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Handle">
        <short>Provides access to the widget set handle for the application instance</short>
        <descr>
          <p>
            <var>Handle</var> is a <var>THandle</var> property which provides access to the widget set handle used for the application instance. Reading the value for the property is redirected to the AppHandle allocated in the widget set class. Setting the value for the property causes the AppHandle in the widget set class to be updated with the new value.
          </p>
          <p>
            Handle is used to send and receive window messages and state change notifications for the application instance using the <b>LCL</b> interface.
          </p>
        </descr>
        <seealso>
          <link id="TWidgetSet.AppHandle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Hint">
        <short>The current Hint text</short>
        <descr>
          <p>
            A hint is a pop-up message that appears briefly while the mouse hovers over a control. It usually displays useful information about how to the UI element, or the type of data that should be entered, etc.
          </p>
          <p>
            Other properties can be used to customize the delay before a Hint is shown, after the mouse is moved away from the control or form, and how long it will remain visible.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HintPause"/>
          <link id="TApplication.HintHidePause"/>
          <link id="TApplication.HintHidePausePerChar"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintColor">
        <short>The color of Hint windows</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintHidePause">
        <short>How long a Hint stays visible, after an mouse move</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintHidePausePerChar">
        <short>
          How long a keystroke extends the time a Hint remains visible (added to HintHidePause)
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.HintHidePause"/>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintPause">
        <short>The delay before a Hint is shown</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintShortCuts">
        <short>Enables the display of keyboard shortcuts (e.g. on menu entries)</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
        <notes><note>not implemented?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintShortPause">
        <short>The pause before a different Hint is displayed</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Icon">
        <short>The icon associated with this application</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.LayoutAdjustmentPolicy">
        <short>
          Indicates the layout and sizing policy used for forms and controls in the application
        </short>
        <descr/>
        <seealso>
          <link id="TLayoutAdjustmentPolicy"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Navigation">
        <short>Allows switching between controls using keyboard navigation</short>
        <descr>
          <p>These keys can be enabled for navigation:</p>
          <ul>
            <li>The Tab key moves the Focus to the next (or previous) control
              in TabOrder.</li>
            <li>The Enter key triggers the default action.</li>
            <li>The Escape key triggers the Cancel action.</li>
            <li>The F1 key brings up context sensitive help.</li>
            <li>The Arrow keys move the focus.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TApplicationNavigationOptions"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainForm">
        <short>The application terminates when this form is closed</short>
        <seealso/>
      <descr>
        <p>
          This property is set when the first form is created using the CreateForm method when FormStyle contains a valueother than <var>fsSplash</var>.
        </p>
      </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainFormHandle">
        <short>Window handle for the MainForm in the application</short>
        <descr>
          <p>
            <var>MainFormHandle</var> is a read-only <var>HWND</var> property which contains the handle for the form instance used as the main form in the application.
          </p>
          <p>
            The value for the property is derived using the <var>OnGetMainFormHandle</var> event handler (when assigned) or a <var>TGetHandleEvent</var> handler assigned in the application. When neither of these mechanisms provides a value other than zero (0), the window handle assigned in the <var>MainForm</var> property is used.
          </p>
          <p>
            MainFormHandle is used in the implementation of methods in WidgetSet classes, primarily for the Windows platform, and in custom-drawn controls.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.MainForm"/>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainFormOnTaskBar">
        <short>
          Controls whether a button is displayed on the task bar for the main form in the application
        </short>
        <descr>
          <p>
            <var>MainFormOnTaskBar</var> is a <var>Boolean</var> property which determines whether the icon for the main form in the appliciation is displayed on the task bar. When MainFormOnTaskBar is set to <b>True</b>, a button representing the main form is displayed on the task bar area in the window manager. When set to <b>False</b>, the button is not displayed in the task bar area.
          </p>
          <p>
            Changing the value in the property causes the Widgetset class to be notified of the new property value.
          </p>
          <p>
            MainFormOnTaskBar is a platform-dependent property. It may not be implemented for all platforms supported for the Lazarus application. In addition, some platforms which display task bar thumbnails (like Windows Vista) may require the property to be set to True.
          </p>
          <p>
            The default value for the property is normally set in the Lazarus project file (<b>.lpr</b>) used to compile the application.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.MainForm"/>
          <link id="TApplication.Icon"/>
          <link id="TApplication.Title"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ModalLevel">
        <short>The number of modal forms shown</short>
        <descr>Tracks modal forms showing another form modally.
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.MoveFormFocusToChildren">
        <short>Indicates if an active control is focused when a form receives focus</short>
        <descr>
          <p>
            MoveFormFocusToChildren is a Boolean property which indicates if an active control is focused when a form receives focus in the application.
          </p>
          <p>
            The default value is True. When set to False, the window or form will still receive focus, but a child control is not selected.
          </p>
           <p>Used in TCustomForm.SetActive.</p>
        </descr>
        <seealso>
          <link id="TCustomForm.Active"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MouseControl">
        <short>The control currently under the mouse</short>
        <descr>Used to detect mouse entering and leaving a control.
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.TaskBarBehavior">
        <short>How forms are represented in the TaskBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.UpdateFormatSettings">
        <short>
          Indicates if application format settings are updated when changed in a widget set class
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActionExecute">
        <short>Default handler for unhandled Actions</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActionUpdate">
        <short>Default handler for unhandled Action updates</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActivate">
        <short>Event handler for activation of the application</short>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDeactivate">
        <short>Event handler for deactivation of the application</short>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.OnGetMainFormHandle">
        <short>
          Event handler used to provide a value for the MainFormHandle property
        </short>
        <descr>
          <p>
            Used in the implementation of the <var>GetMainFormHandle</var> method. Provides the first opportunity to set the handle value before calling the other handlers added to the application.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.MainFormHandle"/>
          <link id="TApplication.MainForm"/>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.OnIdle">
        <short>Event handler for application entering Idle state</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.OnIdleEnd">
        <short>Event handler for application leaving Idle state</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.OnEndSession">
        <short>Event handler for ending a session of the application</short>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>or logoff?</note></notes>
      </element>
      <element name="TApplication.OnQueryEndSession">
        <short>This event handler can deny to end the session</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.OnMinimize">
        <short>Event handler for application minimized</short>
      </element>
      <element name="TApplication.OnMessageDialogFinished">
        <short>
          Event handler signalled when a message dialog in the application has been completed
        </short>
        <descr>Used in the CustomDraw interface.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnModalBegin">
        <short>Event handler for a modal form opened (application entering modal mode)</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnModalEnd">
        <short>Event handler for closing modal forms (application exiting modal mode)</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnRestore">
        <short>Event handler for application restored (from minimized/maximized state)</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDropFiles">
        <short>The default handler for dropped files</short>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
          <link id="TCustomForm.AllowDropFiles"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnHelp">
        <short>Event handler when help is requested</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnHint">
        <short>Event handler when a hint is requested</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnShortcut">
        <short>This event handler can interpret keystrokes as shortcuts,
          before the normal target handles the key</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnShowHint">
        <short>Event handler for showing an Hint</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnUserInput">
        <short>
          Event handler signalled for application handler notifications for user input messages
        </short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
          <link id="TApplication.NotifyUserInputHandler"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDestroy">
        <short>Event handler signalled when the application is freed</short>
        <descr>
          <p>
            <var>OnDestroy</var> is signalled from the <var>Destroy</var> destructor prior to freeing resources allocated in the application class instance. It provides the first opportunity to respond to application shutdown after <var>Flags</var> has been updated to include the <var>AppDestroying</var> enumeration value.
         </p>
        </descr>
        <seealso>
          <link id="TApplication.Destroy"/>
          <link id="TApplication.Flags"/>
          <link id="TApplicationFlags"/>
        </seealso>
    </element>
    <element name="TApplication.OnCircularException">
      <short>
        Handler invoked when there a circular exception occurs before the application is halted.
      </short>
      <descr/>
      <seealso/>
    </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowButtonGlyphs">
        <short>Allows to override the platform default for glyphs on buttons</short>
        <descr>Some platforms show glyphs on all buttons, others don't.</descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowMenuGlyphs">
        <short>Sets the default policy for showing or hiding glyph images in menus</short>
        <descr/>
        <seealso>
          <link id="#lcl.menus.TGlyphShowMode">TGlyphShowMode</link>
        </seealso>
        <notes><note>?</note></notes>
      </element>
        <!-- property Visibility: public -->
        <element name="TApplication.ShowHint">
          <short>Indicates if Hints are displayed for the application</short>
          <descr>
            <p>
              <var>ShowHint</var> is a <var>Boolean</var> property which indicates if <var>Hints</var> are displayed for the application. It is used when tracking the position of the mouse cursor over controls and forms, and determines if the items require a hint display.
            </p>
            <p>
              Setting the value in <var>ShowHints</var> to <b>False</b> causes an existing <var>THintWindow</var> instance in the application to be freed.
            </p>
          </descr>
          <seealso>
            <link id="TApplicationProperties.ShowHint"/>
            <link id="TForm.ShowHint"/>
            <link id="TControl.ParentShowHint"/>
            <link id="THintWindow"/>
          </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowMainForm">
        <short>
          Allows the main form to be shown or hidden when an application is started.
          Default is True.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Title" link="#fcl.CustApp.TCustomApplication.Title"/>
      <element name="TApplication.Scaled">
        <short>
          Indicates if forms and controls in the application can be scaled to different display densities (Pixels per Inch)
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="DefaultApplicationBiDiMode">
        <short>Contains the default BiDiMode value used for the current LCL version</short>
        <descr>Default value is bdLeftToRight. </descr>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintColor">
        <short>The default hint window color</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintPause">
        <short>The default pause before the hint window displays (in milliseconds)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintShortPause">
        <short>The default Hint reshow pause (in milliseconds)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintHidePause">
        <short>The default pause before hint is hidden (in milliseconds)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintHidePausePerChar">
        <short>The default pause added to DefHintHidePause (in milliseconds)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TApplicationProperties">
        <short>
          A component that provides access to the properties for the current application
        </short>
        <descr>
          <p>
            <var>TApplicationProperties</var> is a non-visual component that provides access to a number of application properties, including:
          </p>
          <ul>
            <li>CaptureExceptions</li>
            <li>HelpFile</li>
            <li>Hint</li>
            <li>HintColor</li>
            <li>HintHidePause</li>
            <li>HintPause</li>
            <li>HintShortCuts</li>
            <li>HintShortPause</li>
            <li>ShowButtonGlyphs</li>
            <li>ShowMenuGlyphs</li>
            <li>ShowHint</li>
            <li>ShowMainForm</li>
            <li>Title</li>
            <li>OnException</li>
            <li>OnGetMainFormHandle</li>
            <li>OnIdle</li>
            <li>OnIdleEnd</li>
            <li>OnEndSession</li>
            <li>OnQueryEndSession</li>
            <li>OnMinimize</li>
            <li>OnModalBegin</li>
            <li>OnModalEnd</li>
            <li>OnRestore</li>
            <li>OnDropFiles</li>
            <li>OnHelp</li>
            <li>OnHint</li>
            <li>OnShowHint</li>
            <li>OnUserInput</li>
          </ul>
          <p>
            Values for the properties are assigned in the constructor to the currently assigned values in the <var>Application</var> singleton.
          </p>
          <p>
            At run-time, changes to the properties are also assigned to the <var>Application</var> singleton. For event handler properties, the previous routine is removed as a handler and the new handler is added to the <var>Application</var> singleton. When the component is freed, the event handlers are removed from the <var>Application</var> singleton. The changed properties are not assigned to <var>Application</var> at design-time.
          </p>
          <p>
            <var>TApplicationProperties</var> is available on the <b>Additional</b> tab in the Lazarus IDE Component Palette. <var>TApplicationProperties</var> is similar to the TApplicationEvents class in Delphi.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationProperties.Create"/>
          <link id="TApplication"/>
          <link id="Application"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplicationProperties.FCaptureExceptions" link="#lcl.forms.TApplicationProperties.CaptureExceptions"/>
      <element name="TApplicationProperties.FExceptionDialogType"/>
      <element name="TApplicationProperties.FHelpFile" link="#lcl.forms.TApplicationProperties.HelpFile"/>
      <element name="TApplicationProperties.FHint" link="#lcl.forms.TApplicationProperties.Hint"/>
      <element name="TApplicationProperties.FHintColor" link="#lcl.forms.TApplicationProperties.HintColor"/>
      <element name="TApplicationProperties.FHintHidePause" link="#lcl.forms.TApplicationProperties.HintHidePause"/>
      <element name="TApplicationProperties.FHintPause" link="#lcl.forms.TApplicationProperties.HintPause"/>
      <element name="TApplicationProperties.FHintShortCuts" link="#lcl.forms.TApplicationProperties.HintShortCuts"/>
      <element name="TApplicationProperties.FHintShortPause" link="#lcl.forms.TApplicationProperties.HintShortPause"/>
      <element name="TApplicationProperties.FOnActivate"/>
      <element name="TApplicationProperties.FOnDeactivate"/>
      <element name="TApplicationProperties.FOnDropFiles" link="#lcl.forms.TApplicationProperties.OnDropFiles"/>
      <element name="TApplicationProperties.FOnGetMainFormHandle" link="#lcl.forms.TApplicationProperties.OnGetMainFormHandle"/>
      <element name="TApplicationProperties.FOnModalBegin" link="#lcl.forms.TApplicationProperties.OnModalBegin"/>
      <element name="TApplicationProperties.FOnModalEnd" link="#lcl.forms.TApplicationProperties.OnModalEnd"/>
      <element name="TApplicationProperties.FShowButtonGlyphs" link="#lcl.forms.TApplicationProperties.ShowButtonGlyphs"/>
      <element name="TApplicationProperties.FShowHint" link="#lcl.forms.TApplicationProperties.ShowHint"/>
      <element name="TApplicationProperties.FShowMainForm" link="#lcl.forms.TApplicationProperties.ShowMainForm"/>
      <element name="TApplicationProperties.FShowMenuGlyphs" link="#lcl.forms.TApplicationProperties.ShowMenuGlyphs"/>
      <element name="TApplicationProperties.FTitle" link="#lcl.forms.TApplicationProperties.Title"/>
      <element name="TApplicationProperties.FOnException" link="#lcl.forms.TApplicationProperties.OnException"/>
      <element name="TApplicationProperties.FOnIdle" link="#lcl.forms.TApplicationProperties.OnIdle"/>
      <element name="TApplicationProperties.FOnIdleEnd" link="#lcl.forms.TApplicationProperties.OnIdleEnd"/>
      <element name="TApplicationProperties.FOnHelp" link="#lcl.forms.TApplicationProperties.OnHelp"/>
      <element name="TApplicationProperties.FOnHint" link="#lcl.forms.TApplicationProperties.OnHint"/>
      <element name="TApplicationProperties.FOnShowHint" link="#lcl.forms.TApplicationProperties.OnShowHint"/>
      <element name="TApplicationProperties.FOnUserInput" link="#lcl.forms.TApplicationProperties.OnUserInput"/>
      <element name="TApplicationProperties.FOnEndSession" link="#lcl.forms.TApplicationProperties.OnEndSession"/>
      <element name="TApplicationProperties.FOnQueryEndSession" link="#lcl.forms.TApplicationProperties.OnQueryEndSession"/>
      <element name="TApplicationProperties.FOnMinimize" link="#lcl.forms.TApplicationProperties.OnMinimize"/>
      <element name="TApplicationProperties.FOnRestore" link="#lcl.forms.TApplicationProperties.OnRestore"/>
      <element name="TApplicationProperties.SetExceptionDialog">
        <short>Sets the value for the ExceptionDialog property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetExceptionDialog.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetCaptureExceptions">
        <short>Sets the value for the CaptureExceptions property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetCaptureExceptions.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHelpFile">
        <short>Sets the value for the HelpFile property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HelpFile"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHelpFile.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHint">
        <short>Sets the value for the Hint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.Hint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintColor">
        <short>Sets the value for the HintColor property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintColor"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintColor.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintHidePause">
        <short>Sets the value for the HintHidePause property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintHidePause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintHidePause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintPause">
        <short>Sets the value for the HintPause property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintPause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintPause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintShortCuts">
        <short>Sets the value for the HintShortCuts property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintShortCuts"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintShortCuts.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintShortPause">
        <short>Sets the value for the HintShortPause property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintShortPause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintShortPause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowButtonGlyphs">
        <short>Sets the value for the ShowButtonGlyphs property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowButtonGlyphs"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowButtonGlyphs.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowMenuGlyphs">
        <short>Sets the value for the ShowMenuGlyphs property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowMenuGlyphs"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowMenuGlyphs.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowHint">
        <short>Sets the value for the ShowHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowMainForm">
        <short>Sets the value for the ShowMainForm property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowMainForm"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowMainForm.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetTitle">
        <short>Sets the value for the Title property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.Title"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetTitle.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TApplicationProperties.SetOnActivate">
        <short>Sets the value for the OnActivate property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnActivate"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnActivate.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TApplicationProperties.SetOnDeactivate">
        <short>Sets the value for the OnDeactivate property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnDeactivate"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnDeactivate.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnException">
        <short>Sets the value for the OnException property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnException"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnException.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnGetMainFormHandle">
        <short>Sets the value for the OnGetMainFormHandle property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnGetMainFormHandle.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnIdle">
        <short>Sets the value for the OnIdle property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnIdle"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnIdle.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnIdleEnd">
        <short>Sets the value for the OnIdleEnd property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnIdleEnd"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnIdleEnd.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnEndSession">
        <short>Sets the value for the OnEndSession property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnEndSession"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnEndSession.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnQueryEndSession">
        <short>Sets the value for the OnQueryEndSession property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnQueryEndSession.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnMinimize">
        <short>Sets the value for the OnMinimize property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnMinimize"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnMinimize.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnModalBegin">
        <short>Sets the value for the OnModalBegin property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnModalBegin"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnModalBegin.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnModalEnd">
        <short>Sets the value for the OnModalEnd property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnModalEnd"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnModalEnd.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnRestore">
        <short>Sets the value for the OnRestore property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnRestore"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnRestore.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnDropFiles">
        <short>Sets the value for the OnDropFiles property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnDropFiles.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnHelp">
        <short>Sets the value for the OnHelp property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnHelp"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnHelp.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnHint">
        <short>Sets the value for the OnHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnShowHint">
        <short>Sets the value for the OnShowHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnShowHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnShowHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnUserInput">
        <short>Sets the value for the OnUserInput property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnUserInput"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnUserInput.AValue">
        <short>New value for the property</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TApplicationProperties.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for TApplicationProperties. Create calls the inherited <var>Create</var> method, and sets the defaults values when a new application is being designed, or loads local values for an existing application.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
        </seealso>
      </element>
      <element name="TApplicationProperties.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TApplicationProperties.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. <var>Destroy</var> ensures that event handlers in the class instance are removed from the handlers registered in the global <var>TApplication</var> instance.
          </p>
          <remark>
            Please note: Event handlers are not removed from the Application variable at design-time; they were not added at design-time either.
          </remark>
         <p>
           <var>Destroy</var> calls the inherited destructor prior to exiting from the method.
         </p>
        </descr>
        <seealso>
          <link id="TApplicationProperties.OnActivate"/>
          <link id="TApplicationProperties.OnDeactivate"/>
          <link id="TApplicationProperties.OnException"/>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
          <link id="TApplicationProperties.OnIdle"/>
          <link id="TApplicationProperties.OnIdleEnd"/>
          <link id="TApplicationProperties.OnEndSession"/>
          <link id="TApplicationProperties.OnQueryEndSession"/>
          <link id="TApplicationProperties.OnMinimize"/>
          <link id="TApplicationProperties.OnModalBegin"/>
          <link id="TApplicationProperties.OnModalEnd"/>
          <link id="TApplicationProperties.OnRestore"/>
          <link id="TApplicationProperties.OnDropFiles"/>
          <link id="TApplicationProperties.OnHelp"/>
          <link id="TApplicationProperties.OnHint"/>
          <link id="TApplicationProperties.OnShowHint"/>
          <link id="TApplicationProperties.OnUserInput"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.CaptureExceptions" link="#lcl.forms.TApplication.CaptureExceptions"/>
      <element name="TApplicationProperties.ExceptionDialog">
        <short>Indicates the dialog type displayed for an exception</short>
        <descr>The default value is aedOkCancelDialog.</descr>
        <seealso/>
      </element>
      <element name="TApplicationProperties.HelpFile" link="#lcl.forms.TApplication.HelpFile"/>
      <element name="TApplicationProperties.Hint" link="#lcl.forms.TApplication.Hint"/>
      <element name="TApplicationProperties.HintColor" link="#lcl.forms.TApplication.HintColor"/>
      <element name="TApplicationProperties.HintHidePause" link="#lcl.forms.TApplication.HintHidePause"/>
      <element name="TApplicationProperties.HintPause" link="#lcl.forms.TApplication.HintPause"/>
      <element name="TApplicationProperties.HintShortCuts" link="#lcl.forms.TApplication.HintShortCuts"/>
      <element name="TApplicationProperties.HintShortPause" link="#lcl.forms.TApplication.HintShortPause"/>
      <element name="TApplicationProperties.ShowButtonGlyphs" link="#lcl.forms.TApplication.ShowButtonGlyphs"/>
      <element name="TApplicationProperties.ShowMenuGlyphs" link="#lcl.forms.TApplication.ShowMenuGlyphs"/>
      <element name="TApplicationProperties.ShowHint" link="#lcl.forms.TApplication.ShowHint"/>
      <element name="TApplicationProperties.ShowMainForm" link="#lcl.forms.TApplication.ShowMainForm"/>
      <element name="TApplicationProperties.Title" link="#lcl.forms.TApplication.Title"/>
      <element name="TApplicationProperties.OnActivate" link="#lcl.forms.TApplication.OnActivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplicationProperties.OnDeactivate" link="#lcl.forms.TApplication.OnDeactivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplicationProperties.OnException" link="#lcl.forms.TApplication.OnException"/>
      <element name="TApplicationProperties.OnGetMainFormHandle" link="#lcl.forms.TApplication.OnGetMainFormHandle"/>
      <element name="TApplicationProperties.OnIdle" link="#lcl.forms.TApplication.OnIdle"/>
      <element name="TApplicationProperties.OnIdleEnd" link="#lcl.forms.TApplication.OnIdleEnd"/>
      <element name="TApplicationProperties.OnEndSession" link="#lcl.forms.TApplication.OnEndSession"/>
      <element name="TApplicationProperties.OnQueryEndSession" link="#lcl.forms.TApplication.OnQueryEndSession"/>
      <element name="TApplicationProperties.OnMinimize" link="#lcl.forms.TApplication.OnMinimize"/>
      <element name="TApplicationProperties.OnModalBegin" link="#lcl.forms.TApplication.OnModalBegin"/>
      <element name="TApplicationProperties.OnModalEnd" link="#lcl.forms.TApplication.OnModalEnd"/>
      <element name="TApplicationProperties.OnRestore" link="#lcl.forms.TApplication.OnRestore"/>
      <element name="TApplicationProperties.OnDropFiles" link="#lcl.forms.TApplication.OnDropFiles"/>
      <element name="TApplicationProperties.OnHelp" link="#lcl.forms.TApplication.OnHelp"/>
      <element name="TApplicationProperties.OnHint" link="#lcl.forms.TApplication.OnHint"/>
      <element name="TApplicationProperties.OnShowHint" link="#lcl.forms.TApplication.OnShowHint"/>
      <element name="TApplicationProperties.OnUserInput" link="#lcl.forms.TApplication.OnUserInput"/>
      <!-- object Visibility: default -->
      <element name="TIDesigner">
        <short>The abstract base class for visual Form designers</short>
        <descr>
          <p>
            <var>TIDesigner</var> is a <var>TObject</var> descendant which specifies the interface used for visual Form designers . TIDesigner is the type used for the <var>TCustomForm.Designer</var> property.
          </p>
          <p>
            It is used as the ancestor for <var>TComponentEditorDesigner</var>, and the type expected in the RootDesigner for the Object Inspector and Property editors used in the Lazarus IDE.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Designer"/>
          <link id="FindRootDesigner"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.IsDesignMsg">
        <short>
          <var>IsDesignMsg</var> - receives a message from Sender, and returns True if it is a design message</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Result">
        <short/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Sender">
        <short/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Message">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.Modified">
        <short>Method when design is <var>Modified</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.Notification">
        <short>
          <var>Notification</var> that the supplied Operation has been applied to the
          specified Component
        </short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TIDesigner.Notification.AComponent">
        <short/>
      </element>
      <element name="TIDesigner.Notification.Operation">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.PaintGrid">
        <short>
          <var>PaintGrid</var> - method for painting the grid in the designer</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.ValidateRename">
        <short>
          <var>ValidateRename</var> - method to validate the Rename process</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.ValidateRename.AComponent">
        <short/>
      </element>
      <element name="TIDesigner.ValidateRename.CurName">
        <short/>
      </element>
      <element name="TIDesigner.ValidateRename.NewName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.GetShiftState">
        <short>
          <var>GetShiftState</var> - returns the value of the shift state (whether shifted, Cntl key, Alt key etc)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.GetShiftState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.SelectOnlyThisComponent">
        <short>
          <var>SelectOnlyThisComponent</var> - method to select only the current component in the designer</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.SelectOnlyThisComponent.AComponent">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.UniqueName">
        <short>
          <var>UniqueName</var> - returns a Unique name for the designer, using the BaseName as a starting point</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIDesigner.UniqueName.Result">
        <short/>
      </element>
      <element name="TIDesigner.UniqueName.BaseName">
        <short/>
      </element>
<!-- object Visibility: default -->
      <element name="TFormPropertyStorage">
        <short>
          <var>TFormPropertyStorage</var> - class for storage of a Form's properties</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFormPropertyStorage.FormCreate">
        <short/>
        <descr>Calls the Restore method.</descr>
        <seealso/>
      </element>
      <element name="TFormPropertyStorage.FormCreate.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFormPropertyStorage.FormClose">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormPropertyStorage.FormClose.Sender">
        <short/>
      </element>
      <element name="TFormPropertyStorage.FormClose.CloseAction">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TFormPropertyStorage.Create" link="#rtl.classes.TComponent.Create"/>
      <element name="TFormPropertyStorage.Create.TheOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TFormPropertyStorage.Destroy" link="#rtl.classes.TComponent.Destroy"/>
      <!-- function Visibility: default -->
      <element name="KeysToShiftState">
        <short>Converts modifier keys from the LParam of a
          mouse message to a TShiftState</short>
        <descr/>
        <seealso>
          <link id="ShiftStateToKeys"/>
          <link id="KeyDataToShiftState"/>
          <link id="#rtl.classes.TShiftState">TShiftState</link>
          <link id="#lcl.lcltype.MK_SHIFT">MK_SHIFT</link>
          <link id="#lcl.lcltype.MK_CONTROL">MK_CONTROL</link>
          <link id="#lcl.lcltype.MK_LBUTTON">MK_LBUTTON</link>
          <link id="#lcl.lcltype.MK_RBUTTON">MK_RBUTTON</link>
          <link id="#lcl.lcltype.MK_MBUTTON">MK_MBUTTON</link>
          <link id="#lcl.lcltype.MK_XBUTTON1">MK_XBUTTON1</link>
          <link id="#lcl.lcltype.MK_XBUTTON2">MK_XBUTTON2</link>
        </seealso>
      </element>
      <element name="KeysToShiftState.Result">
        <short/>
      </element>
      <element name="KeysToShiftState.Keys">
        <short>The asynchronous keyboard state</short>
      </element>
      <!-- function Visibility: default -->
      <element name="KeyDataToShiftState">
        <short>
          Converts modifier keys from the LParam keyboard message (WM_KEYUP for
          example) to a TShiftState
        </short>
        <descr/>
        <seealso>
          <link id="#rtl.classes.TShiftState">TShiftState</link>
          <link id="KeysToShiftState"/>
          <link id="ShiftStateToKeys"/>
          <link id="#lcl.lcltype.MK_SHIFT">MK_SHIFT</link>
          <link id="#lcl.lcltype.MK_CONTROL">MK_CONTROL</link>
          <link id="#lcl.lcltype.MK_LBUTTON">MK_LBUTTON</link>
          <link id="#lcl.lcltype.MK_RBUTTON">MK_RBUTTON</link>
          <link id="#lcl.lcltype.MK_MBUTTON">MK_MBUTTON</link>
          <link id="#lcl.lcltype.MK_XBUTTON1">MK_XBUTTON1</link>
          <link id="#lcl.lcltype.MK_XBUTTON2">MK_XBUTTON2</link>
        </seealso>
      </element>
      <element name="KeyDataToShiftState.Result">
        <short/>
      </element>
      <element name="KeyDataToShiftState.KeyData">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="ShiftStateToKeys">
        <short>
          Converts a shift state into a key state value compatible with the key state of a Windows API LParam
        </short>
        <descr>
          <p>
            The Keys value is of the type PtrUInt and is a or'ed combination of the following constants:
          </p>
          <ul>
            <li>MK_Shift</li>
            <li>MK_Control</li>
            <li>MK_LButton</li>
            <li>MK_RButton</li>
            <li>MK_MButton</li>
            <li>MK_XBUTTON1</li>
            <li>MK_XBUTTON2</li>
          </ul>
        </descr>
        <seealso>
          <link id="#rtl.classes.TShiftState">TShiftState</link>
          <link id="KeysToShiftState"/>
          <link id="KeyDataToShiftState"/>
          <link id="#lcl.lcltype.MK_SHIFT">MK_SHIFT</link>
          <link id="#lcl.lcltype.MK_CONTROL">MK_CONTROL</link>
          <link id="#lcl.lcltype.MK_LBUTTON">MK_LBUTTON</link>
          <link id="#lcl.lcltype.MK_RBUTTON">MK_RBUTTON</link>
          <link id="#lcl.lcltype.MK_MBUTTON">MK_MBUTTON</link>
          <link id="#lcl.lcltype.MK_XBUTTON1">MK_XBUTTON1</link>
          <link id="#lcl.lcltype.MK_XBUTTON2">MK_XBUTTON2</link>
        </seealso>
        <notes><note>into what?</note></notes>
      </element>
      <element name="ShiftStateToKeys.Result">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <element name="ShiftStateToKeys.ShiftState">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="WindowStateToStr">
        <short>
          <var>WindowStateToStr</var> - converts a Window state to a string</short>
        <descr/>
        <seealso/>
      </element>
      <element name="WindowStateToStr.Result">
        <short/>
      </element>
      <element name="WindowStateToStr.State">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="StrToWindowState">
        <short>
          <var>StrToWindowState</var> - converts a string to a Window state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="StrToWindowState.Result">
        <short/>
      </element>
      <element name="StrToWindowState.Name">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="dbgs">
        <short>Formats various typed values into readable text</short>
        <descr/>
        <seealso/>
      </element>
      <element name="dbgs.Result">
        <short>The formatted value</short>
      </element>
      <element name="dbgs.State">
        <short/>
      </element>
      <element name="dbgs.Action">
        <short/>
      </element>
      <element name="dbgs.Kind">
        <short/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TFocusState">
        <short>Pointer to focus state information for the last active control in an application</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: default -->
      <element name="SaveFocusState">
        <short>Returns the last focused control in an application</short>
        <descr/>
        <seealso>
          <link id="RestoreFocusState"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="SaveFocusState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RestoreFocusState">
        <short>Restores the last focused control in an application to specified value</short>
        <descr/>
        <seealso>
          <link id="SaveFocusState"/>
        </seealso>
      </element>
      <element name="RestoreFocusState.FocusState">
        <short/>
      </element>
      <!-- function type Visibility: default -->
      <element name="TGetDesignerFormEvent">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TGetDesignerFormEvent.Result">
        <short/>
      </element>
      <element name="TGetDesignerFormEvent.APersistent">
        <short/>
      </element>
      <element name="TIsFormDesignFunction">
        <short/>
        <descr>
          TIsFormDesignFunction is a Boolean function type used in the IsFormDesign variable.
        </descr>
        <seealso>
          <link id="IsFormDesign"/>
        </seealso>
      </element>
      <element name="TIsFormDesignFunction.Result">
        <short>Returns True when the form has csDesignInstance in its component state</short>
      </element>
      <element name="TIsFormDesignFunction.AForm">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="OnGetDesignerForm">
        <short/>
        <descr>
          OnGetDesignerForm is a TGetDesignerFormEvent variable that contains the event handler signalled to get a form with a design surface for the specified form or control.
        </descr>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: default -->
      <element name="GetParentForm">
        <short>Gets the topmost Form containing the specified Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetParentForm.Result">
        <short/>
      </element>
      <element name="GetParentForm.Control">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetDesignerForm">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="GetDesignerForm.Result">
        <short/>
      </element>
      <element name="GetDesignerForm.Control">
        <short/>
      </element>
      <element name="GetDesignerForm.APersistent">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetFirstParentForm">
        <short>Does a recursive search for the first Parent of type TCustomForm</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetFirstParentForm.Result">
        <short/>
      </element>
      <element name="GetFirstParentForm.Control">
        <short/>
      </element>
      <element name="GetTopFormSkipNonDocked">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="GetTopFormSkipNonDocked.Result">
        <short/>
      </element>
      <element name="GetTopFormSkipNonDocked.Control">
        <short/>
      </element>
      <element name="ValidParentForm">
        <short>Gets a valid parent form for the specified control</short>
        <descr>
          <p>
            <var>ValidParentForm</var> is a <var>TCustomForm</var> function used to get a valid parent form for the control specified in the <var>Control</var> argument. <var>TopForm</var> indicates if the return value should contain the absolute root ancestor in the ancestry tree. ValidParentForm calls <var>GetParentForm</var> to get the return value for the routine.
          </p>
          <p>
            ValidParentForm raises an <var>EInvalidOperation</var> exception with the message in <var>sParentRequired</var> when a valid parent form is not found for the specified control.
          </p>
        </descr>
        <errors>
          Raises an EInvalidOperation exception with the message in sParentRequired when a valid parent form is not found for the specified control.
        </errors>
        <seealso/>
      </element>
      <element name="ValidParentForm.Result">
        <short>Form instance that is the parent form for the control</short>
      </element>
      <element name="ValidParentForm.Control">
        <short>Control examined in the routine</short>
      </element>
      <element name="ValidParentForm.TopForm">
        <short>True if all parent forms are located in the routine</short>
      </element>
      <!-- function Visibility: default -->
      <element name="FindRootDesigner">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="FindRootDesigner.Result">
        <short/>
      </element>
      <element name="FindRootDesigner.APersistent">
        <short/>
      </element>
      <element name="GetParentDesignControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="GetParentDesignControl.Result">
        <short/>
      </element>
      <element name="GetParentDesignControl.Control">
        <short/>
      </element>
      <element name="NeedParentDesignControl">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="NeedParentDesignControl.Result">
        <short/>
      </element>
      <element name="NeedParentDesignControl.Control">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="IsAccel">
        <short>Searches for the given virtual key, used as an accelerator</short>
        <descr>
          <p>
            An accelerator consists of an ampersand followed by the accelerator key. Duplicate ampersands are ignored; they denote a literal (displayed) ampersand character (<b>&amp;</b>).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="IsAccel.Result">
        <short>True when the key is used as an accelerator</short>
      </element>
      <element name="IsAccel.VK">
        <short>The virtual key (uppercase ASCII) to find</short>
      </element>
      <element name="IsAccel.Str">
        <short>The string to scan</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="NotifyApplicationUserInput">
        <short>Invokes all application user input handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="NotifyApplicationUserInput.Msg">
        <short>The message to process</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetShortHint">
        <short>Returns the short version of a Hint string</short>
        <descr>
          <p>
            A short Hint is separated from the long Hint by a '|' character. When no such character is found, the whole Hint is returned.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetShortHint.Result">
        <short>The short (or complete) Hint</short>
      </element>
      <element name="GetShortHint.Hint">
        <short>The string containing both a short and long Hint</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetLongHint">
        <short>Returns the long version of a Hint string</short>
        <descr/>
        <seealso>
          <link id="GetShortHint"/>
        </seealso>
      </element>
      <element name="GetLongHint.Result">
        <short/>
      </element>
      <element name="GetLongHint.Hint">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="Application">
        <short>The TApplication singleton</short>
        <descr/>
        <seealso>
          <link id="TApplication"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="Screen">
        <short>The TScreen singleton</short>
        <descr/>
        <seealso>
          <link id="TScreen"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="ExceptionObject">
        <short>Variable representing the current exception object in an application</short>
        <descr>
          <p>
            Used in the implementation of the TApplication.HandleException method.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HandleException"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="HintWindowClass">
        <short>The class used to create hint window instances for an application</short>
        <descr/>
        <seealso/>
      </element>

      <element name="RequireDerivedFormResource">
        <short>
          When True every form must have a resource (e.g. a .res file). An exception is raised if the resource is missing when creating a form.
        </short>
        <descr>
          <p>
            The form resource is the <file>.lfm</file> file compiled into the executable of your application. For this flag, it does not matter if it was compiled via an <file>.lrs</file> file or via <file>fpcres</file>. The resource is automatically loaded by <var>TForm</var> and its descendants when created using the   <var>Create(Owner)</var> method.
          </p>
          <p>
            If the resource file is missing, there is something wrong with either a resource or the unit which contains the faulty form. If the flag is False, you will see a blank form and probably search a long time what is wrong. If you set this flag to True, you get an exception.
          </p>
          <p>
            For creating forms without resources, you have 3 options:
          </p>
          <ul>
            <li>Create a TForm class (not a descendant).</li>
            <li>Construct your form using the CreateNew() constructor.</li>
            <li>It is also possible to disable the exception by setting the global
               variable RequireDerivedFormResource to False.</li>
          </ul>
          <p>
            History:
            Before 0.9.31 there was no exception. Therefore some resource-less forms
            might use the standard constructor Create(Owner) and will now get
            exceptions. This change is Delphi compatible and compatible with
            TFrame and TDataModule components.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- function type Visibility: default -->
      <element name="TMessageBoxFunction">
        <short>The type used for the MessageBox variable</short>
        <descr>
          <p>
            TMessageBoxFunction is an Integer function type which specifies the routine used to perform a message box or dialog.
          </p>
          <p>
            Arguments passed to the function identify the content for the message dialog, including:
          </p>
          <ul>
            <li>Text displayed in the mesaage dialog</li>
            <li>Title used on dialog form</li>
            <li>Flag values that control the buttons and icon for the dialog</li>
          </ul>
          <p>
            The return value contains the modal result returned from the message dialog.
          </p>
        </descr>
        <seealso>
          <link id="MessageBoxFunction"/>
        </seealso>
      </element>
      <element name="TMessageBoxFunction.Result">
        <short/>
      </element>
      <element name="TMessageBoxFunction.Text">
      </element>
      <element name="TMessageBoxFunction.Caption">
        <short/>
      </element>
      <element name="TMessageBoxFunction.Flags">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="MessageBoxFunction">
        <short>
          Provides the routine used to display a message dialog in widget set implementations
        </short>
        <descr>
          <p>
            Normally contains a reference to the <var>DefaultMessageBox</var> function. It may have another function reference assigned to the variable in specific widget set implementations (such as CustomDraw controls).
          </p>
        </descr>
        <seealso>
          <link id="#lcl.dialogs.DefaultMessageBox">DefaultMessageBox</link>
        </seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefaultBorderIcons">
        <short>Maps form border styles to their border icons</short>
        <descr>
          <p>
            <var>DefaultBorderIcons</var> is an array constant with <var>TBorderIcons</var> values indicating the icons available for the various form border styles. Values in the array are indexed by the enumeration values in TFormBorderStyle. Each element in the array contains zero (0) or more values from the TBorderIcon enumeration, and indicates that the icon is used for the form border style.
          </p>
          <p>
            DefaultBorderIcons contains the following values for the corresponding TFormBorderStyle values:
          </p>
          <dl>
            <dt>bsNone</dt>
            <dd>An empty set ([])</dd>
            <dt>bsSingle</dt>
            <dd>[biSystemMenu, biMinimize]</dd>
            <dt>bsSizeable</dt>
            <dd>[biSystemMenu, biMinimize, biMaximize]</dd>
            <dt>bsDialog</dt>
            <dd>[biSystemMenu]</dd>
            <dt>bsToolWindow</dt>
            <dd>[biSystemMenu, biMinimize]</dd>
            <dt>bsSizeToolWin</dt>
            <dd>[biSystemMenu, biMinimize, biMaximize]</dd>
          </dl>
          <p>
            DefaultBorderIcons is used in the implementation of the SetFormBorderStyle method in TCustomForm.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="CreateWidgetset">
        <short>Creates the widget set</short>
        <descr>
          <p>
            <var>CreateWidgetset</var> is a procedure used to create the <var>WidgetSet</var> singleton. CreateWidgetset executes the nitialization handlers for the LCL interface.
          </p>
          <p>
            <var>AWidgetsetClass</var> is the <var>TWidgetsetClass</var> class type used to create the <var>WidgetSet</var> singleton. CreateWidgetset is called from the <file>interfaces.pp</file> unit for a specific widget set implementation (win32, gtk, gtk2, gtk3, qt, qt5, et. al.).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="CreateWidgetset.AWidgetsetClass">
        <short>TWidgetsetClass class type for the desired widget set implementation</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="FreeWidgetSet">
        <short>Destroys singletons for the Screen, Application, and WidgetSet</short>
        <descr>
          <p>
            <var>FreeWidgetSet</var> is a procedure used to free resources allocated to the <var>Screen</var>, <var>Application</var>, <var>Clipboards</var>, and <var>WidgetSet</var> singletons.
          </p>
          <p>
            For Screen, allocated cursors and monitors are destroyed. Application is freed, and set to Nil. All clipboard formats are freed as well. The WidgetSet singleton is freed, and set to Nil.
          </p>
          <p>
            FreeWidgetSet executes the <var>CallInterfaceFinalizationHandlers</var> routine to perform any finalization handlers installed for the <b>LCL</b> interface.
          </p>
        </descr>
        <seealso>
          <link id="Application"/>
          <link id="Screen"/>
          <link id="WidgetSet"/>
          <link id="#lcl.lclproc.CallInterfaceFinalizationHandlers">CallInterfaceFinalizationHandlers</link>
        </seealso>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short>Registers components declared in this unit</short>
        <descr>
          <p>
            <var>Register</var> is a procedure used to register components declared in the <file>forms.pp</file> unit for use in the Lazarus IDE. The <var>TFrame</var> component is added to the <b>Standard</b> tab. In addition, the <var>TScrollBox</var> and <var>TApplicationProperties</var> components are added to the <b>Additional</b> tab.
          </p>
        </descr>
        <seealso/>
      </element>
    </module>
    <!-- Forms -->
  </package>
</fpdoc-descriptions>
